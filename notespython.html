<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes on Python</title>
    <link rel="stylesheet" href="styles/styles.css">
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <span><b>Notes on Python</b></span>

    <p>
        These notes are mainly for me. They may not be completely accurate, but what's most important to me is gaining a
        functional understanding of Python so I can solve problems with it. I only want to gain a deeper understanding
        insofar as it helps clear confusion and debug errors.
    </p>

    <p>
        They are broadly organised as follows:
    <ul>
        <li><a href="#Variables">Variables</a></li>
        <li><a href="#Numbers">Numbers</a></li>
        <li><a href="#Strings">Strings</a></li>
        <li><a href="#Booleans">Booleans</a></li>
        <li><a href="#Lists">Lists</a></li>
        <li><a href="#Tuples">Tuples</a></li>
        <li><a href="#Sets">Sets</a></li>
        <li><a href="#Dictionaries">Dictionaries</a></li>
        <li><a href="#ifMatch">if and match Selections</a></li>
        <li><a href="#whileFor">while and for Loops</a></li>
        <li><a href="#Functions">Functions</a></li>
        <li><a href="#Lambdas">Lambdas</a></li>
        <li><a href="#Comprehensions">Comprehensions</a></li>
        <li><a href="#Generators">Generators</a></li>
        <li>Modules</li>
        <li>Classes and OOP</li>
        <li>Exceptions</li>
    </ul>
    </p>

    <span id="Variables"><b>Variables</b></span>

    <p>
        A variable in Python is created when you first assign it a value:
    <pre><code class="language-python">>>> x = 2</code></pre>
    </p>

    <p>
        In the code above, an object is created to represent the value <code>2</code>.
        A variable <code>x</code> is created if it does not already exist.
        The variable <code>x</code> is then linked to this new object <code>2</code>.
        <br>
        A variable itself never has any <i>type</i>; rather, it refers to a particular
        object at any particular point in time. The object it refers to has a type.
        Despite this very important technical detail, it is not uncommon for people to say that <code>x</code>
        is of type integer, as it refers to an object of type integer.
    </p>

    <p>
        To further emphasize the point that variables have no type, consider the code
        following code:
    <pre><code class="language-python">>>> x = 2
>>> x = 2.5
>>> x = "A"</code></pre>
    </p>

    <p>
        With each assignment, we have simply made <code>x</code> refer to a different type of object.
        <br>
        What happens to the object it was previously referencing?
        To be imprecise, if the object is no longer in <i>use</i>, then the space it occupied is <i>reclaimed</i>.
        This is known as <i>garbage collection</i> and we might go into details later.
    </p>

    <p>
        Consider the second line of the following code:
    <pre><code class="language-python">>>> x = 2
>>> y = x</code></pre>
    </p>

    <p>
        Since the variable <code>x</code> is being used here, it is replaced
        by the object it references, namely <code>2</code>.
        A new variable, <code>y</code>, is created and made to reference the same object.
        Therefore, both <code>x</code> and <code>y</code> end up referencing the same object.
        However, there is no <i>link</i> between the two variables.
    </p>

    <p style="font-size: smaller;">
        In the following code, the last assignment makes <code>x</code> reference the integer <code>3</code>, but
        it does not change the object <code>y</code> refers to.
    <pre><code class="language-python">>>> x = 2
>>> y = x
>>> x = x + 1</code></pre>
    </p>

    <p>
        This might be expected behavior for many, but it
        highlights an important fact:
        There is no way to overwrite the value of the object <code>2</code>, as integers are <i>immutable</i> and thus
        can never be changed <i>in place</i>. On the other hand, we have <i>mutable</i> objects, which can be changed in
        place.
        We will discuss them later.
    </p>

    <p>
        Python allows us to perform sequence assignments. It pairs the values
        on the right side of the assignment operator with the variables on the
        left side, assigning the values one at a time. The left side of a sequence assignment must be a sequence (such
        as a tuple or list of targets), while the right side can be any iterable object, not just a sequence. Both sides
        must have the same length.
    <pre><code class="language-python">>>> A, B = 1, 2
>>> A, B
(1, 2)
>>> [A, B] = [3, 4]
>>> A, B
(3, 4)
>>> [a, b, c] = (1, 2, 3) 
>>> a, b, c
(1, 2, 3)
>>> (a, b, c) = 'ABC'
>>> a, c
('A', 'C')</code></pre>
    </p>

    <p>
        In Python, slicing allows you to assign values to specific parts of a sequence. For more flexible unpacking, you
        can use a <i>starred target</i> on the left side of an assignment. This lets you match and capture multiple
        elements from an iterable on the right-hand side. This technique is known as sequence unpacking.
        There are some edge cases that need to be considered. I might discuss them later!
    <pre><code class="language-python">>>> a, *b = [1, 2, 3, 4]
>>> a, b
(1, [2, 3, 4])
>>> *a, b = [1, 2, 3, 4]
>>> a, b
([1, 2, 3], 4)
>>> a, *b, c = [1, 2, 3, 4]
>>> a, b, c
(1, [2, 3], 4)</code></pre>
    </p>

    <p>
        Python allows for multiple-target and augmented assignments:
    <pre><code class="language-python">>>> x = y = z = 1
>>> x, y, z
(1, 1, 1)
>>> x = 'abc'
>>> x += 'd'
>>> x
'abcd'</code></pre>
    </p>

    <!--Bookmarks-->

    <p>
        It is good practice to give variables descriptive names, unlike in mathematics.
        Moreover, there are certain strict rules that need to be followed; otherwise, you will get a
        syntax error.
    <ul>
        <li>A variable name must start with a letter or the underscore character</li>
        <li>A variable name cannot start with a number</li>
        <li>A variable name can only contain alphanumeric characters and underscores</li>
        <li>Variable names are case-sensitive</li>
        <li>A variable cannot be any of the Python keywords</li>
    </ul>
    </p>

    <p>
        If you want to give a variable a name with more than one word, there are several naming
        conventions to make it more readable.
        We will use the snake case: <code>word1_word2</code>.
    </p>

    <hr>

    <span id="Numbers"><b>Numbers</b></span>

    <p>
        Python supports the usual numeric types: integers and floating-point numbers.
        It also provides more advanced numeric programming support, which we will explore later.
    </p>

    <p>
        Arithmetic operators are used to perform common mathematical operations. These operators include: Addition
        (<code>+</code>), Subtraction (<code>-</code>), Multiplication (<code>*</code>), Division (<code>/</code>),
        Modulus
        (<code>%</code>), Exponentiation (<code>**</code>), and Floor Division (<code>//</code>).
    </p>

    <p>
        If an expression contains more than one operator, Python uses precedence rules to determine which operation to
        perform first.
        Many of these rules are similar to those in mathematics. For example, multiplication takes precedence over
        addition.
        Expressions within parentheses are evaluated first.
    <pre><code class="language-python">>>> 2 * 3 + 5
11
>>> 2 * (3 + 5)
16</code></pre>
    </p>

    <p>
        If an expression consists of different numeric types, Python converts all the operands up to the type of the
        most complex operand in the expression.
        In the following example, the integer is promoted to a floating-point number.
    <pre><code class="language-python">>>> 2.5 + 3 
5.5</code></pre>
    </p>

    <p>
        In Python, you can represent numbers not only in decimal (base 10), but also in hexadecimal (base 16), octal
        (base 8), and binary (base 2) using specific prefixes:
    <pre><code class="language-python">>>> 0xA, 0o11, 0b110
(10, 9, 6)</code></pre>
    </p>

    <p>
        To convert decimal integers to these other bases, you can use Python’s built-in functions:
    <pre><code class="language-python">>>> hex(10), oct(9), bin(6)
('0xa', '0o11', '0b110')</code></pre>
    </p>

    <p>These functions return strings formatted with the appropriate base prefix. To convert a string representation of
        a number back into an integer, use the built-in <code>int</code> function and specify the base:
    <pre><code class="language-python">>>> int('0xA', 16)
10</code></pre>
    </p>

    <p>
        A large value such as 9,999,999 is easier to read when written with commas to group digits. As of Python 3.6,
        numeric literals in Python can contain underscores to group digits together, making them easier to read. These
        underscores do not change the value of the literal.
    <pre><code class="language-python">>>> 9_999_999
9999999</code></pre>
    </p>

    <hr>

    <span id="Strings"><b>Strings</b></span>

    <p>
        Python strings are categorized as immutable sequences, meaning that the characters they contain have a
        left-to-right positional order and cannot be changed in place.
        <br><br>
        Escape sequences let us embed characters that cannot be easily inserted into a string literal. The character
        <code>\</code>,
        along with one or more characters following it in the string literal, is replaced with a single character in the
        resulting string object.
    <pre><code class="language-python">>>> x = 'a\nb'
>>> print(x)
a
b</code></pre>
    </p>

    <p>
        File paths usually contain backslashes. This can cause problems when you try to open the file, as Python
        interprets those backslashes as escape characters. To avoid this problem, you can use the letter <code>r</code>
        before the
        string to tell Python to treat the backslashes as literal characters.
    <pre><code class="language-python">>>> path = r"C:\new\test.dat"</code></pre>
    </p>

    <p>
        You can use Python’s built-in <code>ord</code> function to convert a single character into its corresponding
        Unicode code point (an integer).
    <pre><code class="language-python">>>> ord('A')
65</code></pre>
    </p>

    <p>
        To do the reverse, that is, convert a Unicode code point back to a character, use the <code>chr</code> function.
    <pre><code class="language-python">>>> chr(65)
'A'</code></pre>
    </p>

    <p>
        You can concatenate strings using the <code>+</code> operator and repeat them
        using the <code>*</code> operator. The meaning of an operator depends on the types of objects being processed.
        This is known as polymorphism, which we will discuss later.
        However, Python does not allow combining numbers and strings using the <code>+</code> operator; doing so will
        result in a
        <code>TypeError</code>.
    </p>

    <p>
        Slicing lets you get a part of a sequence, like a string, using two numbers separated by a colon: start:end.
        The first number is the starting index (included), and the second is the ending index (not included).
        Python returns a new object with the items in that range.
        If you leave out the start index, it defaults to 0. If you leave out the end index, it defaults to the length of
        the sequence.
    <pre><code class="language-python">>>> x = 'abcdef'
>>> x[0], x[-2], x[1:3], x[1:], x[:-1]
('a', 'e', 'bc', 'bcdef', 'abcde')</code></pre>
    <p>

    <p>
        You can also add a third number, like this: start:end:step. This is called the step or stride. By default, the
        step is 1 (go one item at a time).
        But you can use it to skip items (e.g., every other item) or even go backward by using a negative step.
    <pre><code class="language-python">>>> x = 'abcdef'
>>> x[::2]
'ace'
>>> x[::-1]
'fedcba'</code></pre>
    </p>

    <p>
        In the slicing expression <code>x[::-1]</code>, the first two bounds can be
        thought of as defaulting to <code>len(x)-1</code> and <code>-1</code>.
    </p>


    <p>
        You can get an IndexError when you try to access a character in a string using its positional index if the index
        does not exist. But with slicing, out-of-range indexes are automatically adjusted to stay within bounds.
    <pre><code class="language-python">>>> x = 'abc'
>>> x[1:100]
'bc'</code></pre>
    </p>

    <p>
        Since strings are an immutable sequence, they cannot be changed in place by assigning to an index.
        This results in a <code>TypeError: 'str' object does not support item assignment</code>.
    <pre><code class="language-python">>>> x = 'abc'
>>> x[0] = 'd'</code></pre>
    </p>


    <p>
        To modify a string in Python, you generally need to create a new string using techniques such as concatenation
        or slicing, and then assign the result back to the original variable. Since strings are immutable, any operation
        that appears to modify a string actually returns a new string object. String methods also generate new string
        objects. If you want to retain these new strings, you need to assign them to variables. Python automatically
        garbage-collects old, unused string objects.
        <br><br>
        Methods are functions that are associated with and operate on objects. Consider the following method call
        expression:
    <pre class="plain"><code class="plain">object.method(arguments)</code></pre>
    </p>

    <p>
        This expression is evaluated from left to right. Python retrieves the method associated with the object, then
        calls it, passing in both the object and the provided arguments. If the method returns a result, that result
        becomes the value of the entire method-call expression.
    </p>

    <p>
        Here are some of the most frequently used string methods. I have not covered the edge cases, so make sure to be
        aware of them to avoid unexpected behavior.
    </p>

    <p>
        The <code>upper</code> method returns the strings in upper case:
    <pre><code class="language-python">>>> x = 'abc'
>>> x.upper()
'ABC'</code></pre>
    </p>


    <p>
        The <code>lower</code> method returns the string in lower case:
    <pre><code class="language-python">>>> x = 'ABC'
>>> x.lower()
'abc'</code></pre>
    </p>

    <p>
        The <code>strip</code> method removes any whitespace from the beginning or the end of a string:
    <pre><code class="language-python">>>> x = 'abc '
>>> x.strip()
'abc'</code></pre>
    </p>

    <p>
        The <code>replace</code> method replaces a substring with another string:
    <pre><code class="language-python">>>> x = 'abc'
>>> x.replace('a', 'd')
'dbc'</code></pre>
    </p>

    <p>
        The <code>split</code> method divides a string into a list of substrings based on a specified separator:
    <pre><code class="language-python">>>> x = "1, 2, 3"
>>> x.split(",")
['1', ' 2', ' 3']</code></pre>
    </p>

    <p>
        F-strings were introduced in Python 3.6 and allow for clean, concise string formatting.
        To specify a string as an f-string, simply put <code>f</code> in front of the string literal,
        and use curly brackets <code>{}</code> as placeholders:
    <pre><code class="language-python">>>> x = 'd'
>>> y = f'abc{x}'
>>> y
'abcd'</code></pre>
    </p>

    <p>
        The expressions inside <code>{}</code> are evaluated at runtime, using the current values of the variables or
        expressions they contain.
        A placeholder can include variables, operations, function calls, and formatting modifiers.
    <pre><code class="language-python">>>> x = 'd'
>>> f'abc{x.upper()}'
'abcD'
>>> x = 2
>>> f'{x:.2f}'
'2.00'
>>> f'The result is {2 * 5}'
'The result is 10'</code></pre>
    </p>

    <hr>

    <span id="Booleans"><b>Booleans</b></span>

    <p>
        Python comes with Booleans with predefined <code>True</code> and
        <code>False</code> objects that are essentially just the integers 1 and 0
        with custom display logic.
    <pre><code class="language-python">>>> True + 1
2</code></pre>
    </p>
    <p>
        It also has a special placeholder object called <code>None</code>, which is commonly
        used to initialize names and objects and designate the absence of a result in functions.
    </p>

    <p>
        Python provides a <code>bool</code> built-in function that can be used to extract the Boolean
        value of an object. You can use this to explicitly check if an object is true, that is,
        nonzero or nonempty.
    <pre><code class="language-python">>>> bool(1)
True
>>> bool(0)
False
>>> bool('abc')
True
>>> bool('')
False</code></pre>
    </p>

    <p>
    <p>
        Comparison operators are used to compare values. For numbers, they work exactly as you'd expect. These operators
        include: Equal to (<code>==</code>), Not equal to (<code>!=</code>), Less than (<code>&lt;</code>), Greater than
        (<code>&gt;</code>), Less than or equal to (<code>&lt;=</code>), and
        Greater than or equal to (<code>&gt;=</code>).
    <pre><code class="language-python">>>> 10 > 9
True
>>> 10 == 9
False
>>> 10 &lt; 9
False</code></pre>
    </p>

    <p>
        Consider the following code. The result is <code>False</code> because floating-point numbers in Python cannot
        represent decimal values exactly
        due to precision limitations.
    <pre><code class="language-python">>>> 1.1 + 2.2 == 3.3
False
>>> 1.1 + 2.2
3.3000000000000003
</code></pre>
    </p>

    <p>
        To handle this issue, you can use the <code>isclose()</code> method from the <code>math</code> module, which
        allows
        you to compare floating-point numbers with a tolerance for small errors:
    <pre><code class="language-python">>>> import math
>>> math.isclose(1.1 + 2.2, 3.3)
True
</code></pre>
    </p>

    <p>
        Alternatively, the <code>Decimal</code> class from the <code>decimal</code> module can be used for precise
        decimal
        arithmetic. It provides an exact representation of decimal numbers, avoiding the rounding issues associated with
        floats:
    <pre><code class="language-python">>>> from decimal import Decimal
>>> Decimal('1.1') + Decimal('2.2') == Decimal('3.3')
True
</code></pre>
    </p>


    <p>
        When comparing different types, Python will attempt to convert values to a common type before making the
        comparison. For example, comparing an integer with a float will
        convert the integer to a float before performing the comparison.
    </p>

    <p>
        Python has three Boolean operators: <code>and</code>, <code>or</code>, and <code>not</code>.
        These operators always return an object, either the object on the left side of the operator
        or the object on the right.
        The <code>and</code> operator returns the first false operand or the last operand if both are true.
        The <code>or</code> operator returns the first true operand or the last if both are false.
        The <code>not</code> operator inverts the truth value.
    <pre><code class="language-python">>>> {} and []
{}
>>> {} and 4
{}
>>> 3 and 4
4
>>> 3 or 4
3
>>> {} or []
[]
>>> not 3
False</code></pre>
    </p>

    <p>
        The net result of all this is that you get a value that is logically true or false when tested in an
        <code>if</code> or <code>while</code> statement, according to the normal definition of <code>or</code> and
        <code>and</code>.
    </p>

    <p>
        Python allows for chained comparisons. For example, the expression <code>X &lt; Y &lt; Z</code> is equivalent to
        <code>X &lt; Y and Y &lt; Z</code>. It's best to avoid this and be as explicit as possible.
    </p>

    <p>
        In Python, there are two primary ways to compare objects: the <code>==</code> operator and the <code>is</code>
        operator. The <code>==</code> operator
        tests for equality, checking whether the values of two objects are the same by comparing all parts of compound
        objects and their nested components, from left to right, until a difference is found. On the other hand, the
        <code>is</code>
        operator tests for object identity, verifying whether two names point to the exact same object in memory,
        essentially checking if they occupy the same address.
    <pre><code class="language-python">>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 3)]
>>> L1 == L2, L1 is L2
(True, False)
>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 2)]
>>> L1 &lt; L2
False</code></pre>
    </p>

    <p>
        You need to be careful, as Python internally caches and reuses certain objects
        for optimization purposes. For example:
    <pre><code class="language-python">>>> x = 256
>>> y = 256
>>> x is y
True</code></pre>
    </p>

    <p>
        The <code>getrefcount</code>function can help explore this behavior by showing how many references an object
        has.
    </p>

    <hr>

    <span id="Lists"><b>Lists</b></span>



    <p>
        Lists are sequences and support many of the same operations as strings.
        <br>
        The <code>+</code> and <code>*</code> operators represent concatenation and repetition, respectively.
        Indexing and slicing work the same way.
    </p>

    <p>
        However, lists are mutable, meaning they support operations that modify
        a list object in place. To illustrate this point, consider the following code:
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = x
>>> x[0] = 4
>>> y
[4, 2, 3]</code></pre>
    </p>

    <p>
        One might expect that the last assignment does not affect <code>y</code>, as it still refers to the old object.
        This is not the case. We have changed a component of the object <code>x</code> refers to. This overwrites the
        value in place, so it affects <code>y</code> because it refers to the same object.
        <br><br>
        If you don't want this, you can make a copy of the object. There are multiple ways to do this, one of which is:
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = x[:]
>>> x[0] = 4
>>> y
[1, 2, 3]</code></pre>
    </p>

    <p> When using a list, you can modify its contents by assigning a new value to a specific item or to a range (slice)
        of items. The length of the sequence being assigned does not need to match the length of the slice being
        replaced. Slice assignment can be used to replace, expand, or shrink the subject list.
    <pre><code class="language-python">>>> x = [1, 2, 3] 
>>> x[1:2] = [4, 5] 
>>> x 
[1, 4, 5, 3] 
>>> x[1:1] = [6, 7] 
>>> x 
[1, 6, 7, 4, 5, 3] 
>>> x[1:2] = [] 
>>> x 
[1, 7, 4, 5, 3]</code></pre>
    </p>

    <p>
        Like strings, Python list objects also support type-specific method calls,
        most of which modify the list itself.
    </p>

    <p>
        The <code>insert</code> method can be used to insert items at a specified location without replacing any of the
        existing items.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> x.insert(2, 5)
>>> x
[1, 2, 5, 3, 4]</code></pre>
    </p>

    <p>
        To add an item to the end of the list, use the <code>append</code> method.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> x.append(4)
>>> x
[1, 2, 3, 4]</code></pre>
    </p>

    <p>
        To append elements from another list to the current list, use the <code>extend</code> method.
        The elements will be added to the end of the list.
        The <code>extend</code> method does not have to append lists, you can add any iterable object.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = [4, 5]
>>> x.extend(y)
>>> x
[1, 2, 3, 4, 5]</code></pre>
    </p>

    <p>
        The <code>remove</code> method removes the specified item.
        If there are more than one item with the specified value, then the method removes the first occurrence.
    <pre><code class="language-python">>>> x = [1, 1, 2, 3]
>>> x.remove(1)
>>> x
[1, 2, 3]</code></pre>
    </p>

    <p>
        The <code>pop</code> method removes and returns the item from the specified index.
        If no index is specified, then it removes the last item.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> x.pop(2)
3
>>> x
[1, 2, 4]
>>> x.pop()
4
>>> x
[1, 2]</code></pre>
    </p>

    <p>
        The <code>del</code> keyword also removes item from specied index. The syntax is different.
        You can use it also to delete the entire list.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> del x[2]
>>> x
[1, 2, 4]
>>> del x</code></pre>
    </p>

    <p>
        The <code>clear</code> method empties the list but it does not delete it.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> x.clear()
>>> x
[]</code></pre>
    </p>

    <p>
        List objects have a <code>sort</code> method that sorts the list alphanumerically, ascending by default.
        Just make sure that the items are of the same data type.
        <br>
        To sort descending use the keyword argument <code>reverse = True</code>.
        Alternatively, one can use the <code>reverse</code> method.
    <pre><code class="language-python">>>> x = [3, 1, 2]
>>> x.sort()
>>> x
[1, 2, 3]
>>> x.sort(reverse = True)
>>> x
[3, 2, 1]
>>> x.reverse()
>>> x
[1, 2, 3]</code></pre>
    </p>

    <p>
        You can also sort based on a function by using the keyword argument <code>key = function</code>.
        The function will return a value for each item in list based on which the list will be sorted.
        The <code>sort</code> method is case-sensitive. To avoid unexpect results you can use <code>str.lower</code>
        as a key function.
    <pre><code class="language-python">>>> def myfunc(n):
...     return abs(n - 50)
... 
>>> x = [100, 50, 65, 82, 23]
>>> x.sort(key = myfunc)
>>> x
[50, 65, 23, 82, 100]</code></pre>
    </p>

    <p>
        Instead of using slice syntax, you can also use the <code>copy</code> method or the
        <code>List</code> constructor.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = list(x)
>>> z = x.copy()
>>> y, z
([1, 2, 3], [1, 2, 3])</code></pre>
    </p>

    <p>
        If a collection object contains a reference to itself, it is called a cyclic object.
        Python prints a <code>[...] </code> whenever it detects a cycle in the object back to itself, rather than
        getting stuck in an infinite loop.
        Cyclic structures may cause code of your own to fall into unexpected loops if you don't anticipate them.
    <pre><code class="language-python">>>> L = ['a']
>>> L.append(L)
>>> L
['a', [...]]
>>> L[1]
['a', [...]]
</code></pre>
    </p>

    <hr>

    <span id="Tuples"><b>Tuples</b></span>

    <p>
        Tuples, like strings, are immutable sequences. There are certain
        peculiarities one must be aware of when working with them. For example,
        if you want a single-item tuple, you need to add a trailing comma:
    <pre><code class="language-python">>>> x = (2)
>>> x
2
>>> x = (2,)
>>> x
(2,)</code></pre>
    </p>

    <p>
        Python allows you to omit the opening and closing round brackets for a tuple
        where it is not ambiguous to do so:
    <pre><code class="language-python">>>> x = 2, 3, 4
>>> x
(2, 3, 4)</code></pre>
    </p>

    <p>
        Tuples don't provide the same methods as strings, lists, or
        dictionaries. For example, there is no built-in <code>append</code> method.
        A workaround for modifying a tuple is to convert it into a list, make your changes,
        and then convert it back into a tuple using the <code>tuple</code> constructor.
        The immutability of tuples provides some integrity; you can be sure that
        a tuple won't be changed elsewhere in a program unintentionally.
    </p>

    <hr>

    <span id="Sets"><b>Sets</b></span>

    <p>Python sets are unordered collections of unique and immutable (hashable) elements. Unlike lists or tuples, sets
        do not allow duplicates and do not maintain any order. You can create a set using the built-in <code>set</code>
        function
        with any iterable, or with curly brace (<code>{}</code>) literals.
    <pre><code class="language-python">>>> A = set('abc')
>>> B = {'d', 'e', 'f'}
>>> A, B
({'c', 'a', 'b'}, {'e', 'd', 'f'})</code></pre>
    </p>

    <p>
        Sets support fast membership testing and standard set operations like union, intersection, difference, subset
        and superset checks:
    <pre><code class="language-python">>>> A = {1, 2, 3, 4}
>>> B = {2, 4, 5, 6}
>>> A & B
{2, 4}
>>> A | B
{1, 2, 3, 4, 5, 6}
>>> A - B
{1, 3}
>>> A > B
False</code></pre>
    </p>

    <p>
        Sets are especially handy for eliminating duplicates, comparing collections regardless of order, or checking
        what's missing or extra:
    <pre><code class="language-python">>>> list(set([1, 2, 2, 3, 1]))
[1, 2, 3]
>>> set('learn') - set('ear')
{'n', 'l'}
>>> set('note') == set('tone')
True</code></pre>
    </p>

    <p>
        Regular sets are mutable, meaning you can add or remove items using methods like <code>add</code> and
        <code>remove</code>.
        However, the elements themselves must be immutable. You can use the <code>update</code> method to add items
        from an iterable object.
    </p>

    <hr>

    <span id="Dictionaries"><b>Dictionaries</b></span>

    <p>Dictionaries are key-based collections of objects. Items are stored and retrieved using keys, rather than by
        positional index as in lists. Internally, dictionaries are implemented as hash tables.
    </p>

    <p> When you assign a new key to a dictionary, a new key-value pair is added to the dictionary. This differs from
        lists, where you can only assign values to existing indices. Dictionary keys are not limited to strings; any
        immutable object (such as numbers, strings, or tuples) can be used as a key.
    </p>

    <p>As of Python 3.7, dictionaries preserve the insertion order of keys as an implementation detail, and this
        behavior became an official part of the Python language specification in Python 3.8.
    <pre><code class="language-python">>>> D = {'a': 1, 'b': 2, 3: 'c'}
>>> D
{'a': 1, 'b': 2, 3: 'c'}
>>> D['e'] = 4
>>> D
{'a': 1, 'b': 2, 3: 'c', 'e': 4}
>>> D = {'a' : 1, 'a': 2}
>>> D
{'a': 2}</code></pre>
    </p>

    <p>
        You can build dictionaries using the <code>dict</code> constructor.
    <pre><code class="language-python">>>> x = dict(a = 1, b = 2)
>>> x
{'a': 1, 'b': 2}</code></pre>
    </p>

    <p>
        Dictionary methods <code>keys</code>, <code>values</code>, and <code>items</code> return iterable objects
        containing keys, values, and (key,
        value) pairs, respectively, which can be used in loops or converted to lists for display. Any changes done to
        the dictionary will be
        reflected accordingly.
    <pre><code class="language-python">>>> x = {'a' : 1, 'b': 2, 'c': 3}
>>> list(x.keys())
['a', 'b', 'c']
>>> list(x.values())
[1, 2, 3]
>>> list(x.items())
[('a', 1), ('b', 2), ('c', 3)]
>>> x['d'] = 4
>>> list(x.keys())
['a', 'b', 'c', 'd']</code></pre>
    </p>

    <p>
        Fetching a nonexistent key is normally an error, but the <code>get</code>
        method returns a default value, <code>None</code>, or a passed-in default if the key
        doesn't exist.
    <pre><code class="language-python">>>> D = {'a' : 1}
>>> D.get('b')
>>> D.get('b', 2)
2</code></pre>
    </p>

    <p>
        The <code>update</code> method merges the keys and values of one
        dictionary into another, both adding new entries for new keys and blindly
        overwriting values of existing keys if there's a clash. The dictionary's <code>pop</code>
        method deletes a key from the dictionary and returns the value it had, similar to other
        <code>pop</code> methods.
    <pre><code class="language-python">>>> D = {'a': 1, 'b': 2}
>>> D.update({'c': 3})
>>> D
{'a': 1, 'b': 2, 'c': 3}
>>> D.pop('a')
1
>>> D
{'b': 2, 'c': 3}</code></pre>
    </p>

    <hr>

    <span id="ifMatch"><b>if and Match Selections</b></span>

    <p>
        All Python compound statements, statements that have other statements nested inside them, follow the same
        general pattern of a header line terminated in a colon, followed by a nested block of code usually indented
        underneath the header line, like this:
    <pre style="background-color: #f0f0f0 !important;"><code style="font-size: smaller;">Header line:
	Nested statement block</code></pre>
    </p>

    <p>
        Python relies on indentation (whitespace at the beginning of a line) to define scope in the code. Other
        programming languages often use curly brackets for this purpose. Consider the following code: Python evaluates
        the condition inside an <code>if</code> statement and runs the appropriate code based on whether the condition
        is <code>True</code> or <code>False</code>.
    <pre><code class="language-python">>>> a = 33
>>> b = 200
>>> if b > 0:
...     print('b is greater than a')
... 
b is greater than a</code></pre>
    </p>

    <p>
        The <code>elif</code> keyword in Python stands for else if.
        It allows you to check a new condition if the previous <code>if</code> or <code>elif</code> conditions were not
        true. You can use multiple <code>elif</code> statements to test several different conditions in sequence.
    <pre><code class="language-python">>>> a = 33
>>> b = 33
>>> if b > a:
...     print('b is greater than a')
... elif a == b:
...     print('a and b are equal')
... 
a and b are equal</code></pre>
    </p>

    <p>
        The <code>else</code> keyword catches anything which isn't caught by the preceding conditions.
    <pre><code class="language-python">>>> a = 200
>>> b = 33
>>> if b > a:
...     print('b is greater than a')
... elif a == b:
...     print('and b are equal')
... else:
...     print('a is greater than b')
... 
a is greater than b</code></pre>
    </p>

    <p>
        If you have only one statement to execute, you can put it on the same line as the if statement.
    <pre><code class="language-python">>>> if a > b: print("a is greater than b")
... 
a is greater than b</code></pre>
    </p>

    <p>
        If you have only one statement to execute, one for <code>if</code>,
        and one for <code>else</code>, you can put it all on the same line:
    <pre><code class="language-python">>>> a = 2
>>> b = 330
>>> print("A") if a > b else print("B")
B</code></pre>
    </p>

    <p>
        You can also have multiple else statements on the same line.
    <pre><code class="language-python">>>> a = 330
>>> b = 330
>>> print("A") if a > b else print("=") if a == b else print("B")
=</code></pre>
    </p>

    <p>
        The <code>match</code> statement is used to perform different actions based on different conditions. Instead of
        writing many if/else statements, you can use the match statement. The <code>match</code> statement selects one
        of many code blocks to be executed. Here's how it works: the match expression is evaluated once. The value of
        the expression is then compared with the values of each case. If there is a match, the associated block of code
        is executed.
    <pre><code class="language-python">>>> day = 2
>>> match day:
...     case 1:
...             print('Monday')
...     case 2:
...             print('Tuesday')
... 
Tuesday</code></pre>
    </p>

    <p>
        You can use the underscore character <code>_</code> as a fallback case when no other match is found, similar to
        a default case. It will always match, so it should be placed at the end of the <code>match</code> statement.
        To check for multiple values in a single case, use the pipe character <code>|</code> as an <code>OR</code>
        operator.
        You can also include an <code>if</code> condition in a case to apply additional checks.
    </p>

    <hr>

    <span id="whileFor"><b>while and for Loops</b></span>

    <p>
        <code>while</code> statement repetedly executes an associated block
        of statements as long as a test at the top keeps evaluating to a
        true value.
    <pre><code class="language-python">>>> a = 0; b = 10
>>> while a &lt; b:
...     print(a, end = ' ')
...     a += 1
... 
0 1 2 3 4 5 6 7 8 9</code></pre>
    </p>

    <p>
        The <code>break</code> and <code>continue</code> statements control the flow inside a <code>while</code> loop.
        They can be placed anywhere within the loop's body, but are often used inside <code>if</code> statements to
        react to specific conditions.
        <code>break</code> exits the nearest enclosing loop immediately, skipping any remaining code in the loop
        body.
        <code>continue</code> skips the rest of the current iteration and jumps back to the loop’s condition check.
    <pre><code class="language-python">>>> a = 0; b = 10
>>> while a &lt; b:
...     if a == 3:
...         a += 1
...         continue
...     if a == 8:
...         break
...     print(a, end=' ')
...     a += 1
... 
0 1 2 4 5 6 7 </code></pre>
    </p>

    <p>
        The <code>else</code> statement can be used with a <code>while</code> loop to run a block of code once after the
        loop condition becomes false, but only if the loop was not exited using a <code>break</code>.

    <pre><code class="language-python">>>> a = 0
>>> while a &lt; 5:
...     print(a, end = ' ')
...     a += 1
... else:
...     print('Loop finished normally')
... 
0 1 2 3 4 Loop finished normally</code></pre>
    </p>

    <p>
        The <code>pass</code> statement is a no-operation placeholder. It is roughly to
        statements what <code>None</code> is to objects. For example:
    <pre><code class="language-python">>>> while True:
...     pass
... </code></pre>
    </p>

    <p>
        The Python <code>for</code> loop starts with a header line that specifies an assignment target (or targets),
        along with the iterable object you want to step through. This header is followed by a block of indented
        statements that you want to execute repeatedly.

        When Python runs a <code>for</code> loop, it assigns each item from the iterable to the target variable, one by
        one, and executes the loop body for each item.

        The <code>for</code> loop also supports an optional <code>else</code> block, which works the same way as in a
        <code>while</code> loop.

        The <code>break</code> and <code>continue</code> statements also behave the same in a <code>for</code> loop as
        they
        do in a <code>while</code> loop.
    <pre><code class="language-python">>>> for x in [1, 2, 3]:
...     print(x, end = ' ')
... 
1 2 3
>>> for (x, y) in [(1, 2), (3, 4), (5, 6)]:
...     print(x, y)
... 
1 2
3 4
5 6</code></pre>
    </p>

    <p>
        The built-in functions <code>range</code>, <code>zip</code>, and <code>enumerate</code>
        allow you to write more powerful and flexible loop iterations in Python.
    </p>

    <p>
        With one argument, <code>range</code> generates a series of integers starting from zero up to, but not
        including, the specified value.
        With two arguments, the first argument acts as the inclusive lower bound, and the second argument as the
        exclusive upper bound.
        With three arguments, the third argument specifies the step, which defaults to +1.
    <pre><code class="language-python">>>> list(range(5))
[0, 1, 2, 3, 4]
>>> list(range(2, 5))
[2, 3, 4]
>>> list(range(1, 5, 2))
[1, 3]</code></pre>
    </p>

    <p>
        The <code>zip</code> function can take one or more sequence arguments (more generally, any type of iterable
        object) and returns an iterator
        that produces tuples, each containing elements from the corresponding positions in the input sequences.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> y = ['a', 'b', 'c', 'd']
>>> list(zip(x, y))
[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]</code></pre>
    </p>

    <p>
        The <code>enumerate</code> function takes an iterable and returns an iterator that produces
        tuples, where each tuple contains the index and the corresponding item from the iterable.
    <pre><code class="language-python">>>> x = 'abcd'
>>> list(enumerate(x))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]</code></pre>
    </p>

    <hr>

    <span id="Functions"><b>Functions</b></span>

    <p>
        In Python, functions are defined using the <code>def</code> keyword. When Python encounters a <code>def</code>
        statement, it creates a function object and assigns it to the function's name, allowing the function to be
        referenced, assigned to variables, or stored in collections. The code inside the function doesn't run until the
        function is called, and <code>def</code> statements themselves are not executed until reached. Functions in
        Python can also have custom attributes attached to them to store additional data. The <code>return</code>
        statement, which can appear anywhere in the function body, ends the function call and sends a result back to the
        caller. If no value is specified with <code>return</code>, Python returns <code>None</code> by default.
    <pre><code class="language-python">>>> def adder(x, y):
...     return x + y
... 
>>> myfunc = adder
>>> myfunc(2, 3)
5</code></pre>
    </p>

    <p>
        Names assigned inside a function using <code>def</code> are local to that function and can only be accessed
        within its scope. These names are not visible outside the function, meaning you can't refer to them from outside
        the function body. Additionally, names defined inside a function don't interfere with variables in other scopes,
        even if the same name is used. This behavior is governed by Python's LEGB (Local, Enclosing, Global, Built-in)
        rule, which dictates the order in which Python looks for a variable.
    <pre><code class="language-python">>>> x = 300
>>> def myfunc():
...     x = 200
...     return x
... 
>>> myfunc()
200
>>> x
300</code></pre>
    </p>

    <p>
        If you need to create a global variable but are stuck in the local scope, you can use the <code>global</code>
        keyword.
        The <code>global</code> keyword makes the variable global. Additionally, use the <code>global</code> keyword if
        you want to modify a
        global variable inside a function.
    <pre><code class="language-python">>>> def myfunc():
...     global x
...     x = 300
... 
>>> myfunc()
>>> x
300
>>> y = 200
>>> def myfunc():
...     global y
...     y = 300
... 
>>> myfunc()
>>> y
300</code></pre>
    </p>

    <p>
        The <code>nonlocal</code> keyword is used to work with variables inside nested
        functions. The <code>nonlocal</code> keyword makes the variable belong to the outer
        function.
    <pre><code class="language-python">>>> def myfunc1():
...     x = 1
...     def myfunc2():
...             nonlocal x
...             x = 2
...     myfunc2()
...     return x
... 
>>> myfunc1()
2</code></pre>
    </p>

    <p> To understand how argument passing works in Python, let's examine the following code: Inside the function
        <code>f</code>, the variable <code>a</code> is assigned the value <code>1</code>. However, this change only
        affects the variable <code>a</code> within the function itself, and does not impact the value of <code>b</code>
        outside the function. This is because Python uses pass-by-assignment (also called
        pass-by-object-reference). When a variable is passed into a function, what actually gets passed is a reference
        to the object, not the object itself. If the object is reassigned within the function (like <code>a = 1</code>),
        it doesn't affect the original variable outside the function.
    <pre><code class="language-python">>>> def f(a):
...     a = 1
... 
>>> b = 2
>>> f(b)
>>> b
2</code></pre>
    </p>

    <p>
        However, when arguments are passed as mutable objects like lists and dictionaries, changes made in-place to such
        objects may live on after a function exits.
    <pre><code class="language-python">>>> def f(a):
...     a[0] = 2
... 
>>> b = [1, 4, 6]
>>> f(b)
>>> b
[2, 4, 6]</code></pre>
    </p>

    <p>
        If you don't want in-place changes to impact the objects we pass, you can simply make explicit copies of mutable
        objects.
    </p>

    <p>
        Python matches names by <i>position</i> from left to right. In the following, <code>a</code> is matched to
        <code>1</code>, <code>b</code> is matched to <code>2</code>, and so on. Keyword arguments allow you to match by
        <i>name</i>, instead of by position. You can even combine positional and keyword arguments in a single call. In
        this case, all positionals are matched first from left to right in the definition, before keywords are matched
        by name.
    <pre><code class="language-python">>>> def f(a, b, c):
...     print(a, b, c)
... 
>>> f(1, 2, 3)
1 2 3
>>> def f(a, b, c):
...     print(a, b, c)
... 
>>> f(1, 2, 3)
1 2 3
>>> f(c = 1, b = 3, a = 2)
2 3 1</code></pre>
    </p>

    <p>
        Defaults allow you to make selected function arguments <i>optional</i>. If not
        passed by value, the argument is assigned its default. You can also combine keywords and defaults.
    <pre><code class="language-python">>>> f(c = 1, b = 3, a = 2)
2 3 1
>>> def f(a, b = 2, c = 3):
...     print(a, b, c)
... 
>>> f(1)
1 2 3
>>> f(5, 4, 3)
5 4 3</code></pre>
    </p>

    <p>
        The argument-matching extensions <code>*</code> and <code>**</code> are
        designed to support any number of arguments. They can appear in function definition and function calls.
    </p>

    <p>
        When a function is called, Python collects all the positional arguments into a new tuple and assigns the
        variable <code>args</code> to that tuple.
    <pre><code class="language-python">>>> def f(*args):
...     print(args)
... 
>>> f()
()
>>> f(1)
(1,)
>>> f(1, 2, 3)
(1, 2, 3)</code></pre>
    </p>

    <p>
        The <code>**kwargs</code> syntax is similar, but it collects keyword arguments into a new dictionary.
    <pre><code class="language-python">>>> def f(**kwargs):
...     print(kwargs)
... 
>>> f()
{}
>>> f(a = 1, b = 2)
{'a': 1, 'b': 2}</code></pre>
    </p>

    <p>
        You can combine regular arguments, <code>*args</code>, and <code>**kwargs</code> to create flexible function
        signatures. For example, in the following:
        <code>1</code> is passed to <code>a</code> by position, <code>2</code> and <code>3</code> are collected into the
        <code>pargs</code> tuple, and <code>x</code> and <code>y</code> are collected into the <code>kargs</code>
        dictionary.
    <pre><code class="language-python">>>> def f(a, *args, **kwargs):
...     print(a, args, kwargs)
... 
>>> f(1, 2, 3, x = 1, y = 2)
1 (2, 3) {'x': 1, 'y': 2}</code></pre>
    </p>

    <p>
        The <code>*</code> syntax can be used when calling a function to unpack a collection of arguments, such as a
        tuple or any other iterable, into individual positional arguments. For example, you can pass a tuple with four
        arguments to a function, and Python will unpack them into separate arguments.
    <pre><code class="language-python">>>> def func(a, b, c):
...     print(a, b, c)
... 
>>> func(*(1, 2, 3))
1 2 3</code></pre>
    </p>

    <p>
        Similarly, the <code>**</code> syntax can be used to unpack a dictionary into key-value pairs, where the
        dictionary keys are used as argument names (keywords) and the values are passed as the corresponding argument
        values.
    <pre><code class="language-python">>>> def func(a, b, c):
...     print(a, b, c)
... 
>>> func(**{'a': 1, 'b': 2, 'c': 3})
1 2 3</code></pre>
    </p>

    <p>
        Starting from Python 3.5, it is possible to use multiple <code>*</code> and <code>**</code> items in function
        calls to unpack multiple iterables and mappings. The <code>*</code> unpacks positional arguments, while
        <code>**</code> unpacks keyword arguments. However, note that <code>*</code> must appear before <code>**</code>
        when used together, as per Python's formal argument-passing rules. There are some other peculiarities that we
        might discuss later.
    <pre><code class="language-python">>>> def func(a, b, c, d, e, f):
...     print(a, b, c, d, e, f)
... 
>>> func(1, *(2, 3, 4), **{'e': 5, 'f': 6})
1 2 3 4 5 6</code></pre>
    </p>

    <p>
        You can specify that a function can have only positional arguments by adding <code>/</code> after the positional
        arguments. To specify that a function can have only keyword arguments, add <code>*</code> before the arguments.
        These two types of arguments can be combined in the same function. Any argument before the <code>/</code> is
        positional-only, and any argument after the <code>*</code> is keyword-only.
    <pre><code class="language-python">>>> def func(a, b, /, c, *, d):
...     print(a, b, c, d)
... 
>>> func(1, 2, c = 3, d = 4)
1 2 3 4
</code></pre>
    </p>

    <hr>

    <span id="Lambdas"><b>Lambdas</b></span>

    <p>
        A lambda function is a small, anonymous function.
        A lambda function can take any number of arguments, but it can only have one expression. The result of that
        expression is automatically returned.
        Syntax: <code>lambda arguments: expression</code>
    <pre><code class="language-python">>>> x = lambda a: a + 10
>>> x(5)
15
>>> x = lambda a, b: a*b
>>> x(5, 6)
30</code></pre>
    </p>

    <p>
        The power of lambda is better shown when you use them as an anonymous function inside another function.
        Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown
        number.
        Use that function definition to make a function that always doubles or triples the number you send in.
    <pre><code class="language-python">>>> def func(n):
...     return lambda a: a*n
... 
>>> double = func(2)
>>> double(11)
22
>>> triple = func(3)
>>> triple(9)
27</code></pre>
    </p>

    <hr>

    <span id="Comprehensions"><b>Comprehensions</b></span>

    <p> List comprehensions can be used to build a new list by applying an expression to each item in a sequence or,
        more generally, any iterable. Similarly, set comprehensions create a set, which automatically removes
        duplicates.
    <pre><code class="language-python">>>> L = [x*2 for x in 'abc'] 
>>> L [
'aa', 'bb', 'cc'] 
>>> S = {x*2 for x in 'abc'} 
>>> S 
{'aa', 'cc', 'bb'}</code></pre>
    </p>

    <p> Comprehensions also support extensions such as <code>if</code> filters and nested <code>for</code> loops. </p>
    <pre><code class="language-python">>>> L = [x*2 for x in 'abc' if x >= 'b'] 
>>> L 
['bb', 'cc'] 
>>> [x + y for x in 'abc' for y in '123'] 
['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3']</code></pre>

    <p>
        Dictionary comprehensions run an implicit loop, collecting the key/value
        results of expressions on each iteration and using them to fill out a new dictionary.
        <pre><code class="language-python">>>> D = {x: x**2 for x in [1, 2, 3]}
>>> D
{1: 1, 2: 4, 3: 9}
>>> D = {x: x*4 for x in 'abc'}
>>> D
{'a': 'aaaa', 'b': 'bbbb', 'c': 'cccc'}</code></pre>
    </p>

    <hr>

    <span id="Generators"><b>Generators</b></span>


    <br><br>

    <hr>


    <!--Bookmark-->



    <div class="container-row scrollable">
        <div>
            If you want to specify the data type of a variable then this can be done with casting.
        </div>
        <div class="right-column">
            <pre><code class="language-python">age = int(23)
weight = float(65) # weight will be 65.0
category = str(5) # category will be "5"</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The data type of a variable can be found using the <code>type()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">print(type(age)) # Output: &ltclass 'int'&gt
print(type(weight)) # Output: &ltclass 'float'&gt
print(type(category)) # Output: &ltclass 'str'&gt</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Strings</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Using triple single or double quotes it is possible to assign a multiline string to a variable.
        </div>
        <div class="right-column">
            <pre><code class="language-python">text1 = """This is a
multiline sentence."""</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To check if certain characters are present or not present in a string,
            we can use the keyword <code>in</code> or <code>not in</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">text = "Hello World"
print("World" in text) # Output: True
print(" World" in text) # Output: True
print("world" in text) # Output: False
print("Hi" not in text) # Output: True</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            A object made from a class with <code>__len__</code> function that
            returns <code>0</code> or <code>False</code> will be evaluated to <code>False</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class myclass():
  def __len__(self):
    return 0

myobj = myclass()
print(bool(myobj))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The built-in function <code>isinstance()</code> returns a boolean value.
            It is used to determine whether an object is of certain data type.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x  = 2
print(isinstance(x, int))</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Membership Operators</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Membership operators are used to test if a sequence is presented in an object.
        </div>
        <div class="right-column">
            <div class="scrollable">
                <table class="three-columns">
                    <tr style="font-weight: bold;">
                        <td>Operator</td>
                        <td>Description</td>
                        <td>Example</td>
                    </tr>
                    <tr>
                        <td><code>in</code></td>
                        <td>Returns <code>True</code> if a sequence with the specified value
                            is present in the object</td>
                        <td><code>x in y</code></td>
                    </tr>
                    <tr>
                        <td><code>not in</code></td>
                        <td>Returns <code>True</code> if a sequence with the specified value
                            is not present in the object</td>
                        <td><code>x in y</code></td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <br>

    <div class="container-row scrollable">
        <div>
            To determine if a specified key is present in a dictionary use the <code>in</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Recursion.
            <br><br>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Object-Oriented Programming</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Classes/Objects</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Python is an object oriented programming language.
            <br><br>
            Almost everything in Python is an object, with its properties and methods.
            <br><br>
            A Class is like an object constructor, or a "blueprint" for creating objects.
            <br><br>
            To create a class, use the keyword <code>class</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyClass:
  x = 5</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Now we can use the class named MyClass to create objects.
        </div>
        <div class="right-column">
            <pre><code class="language-python">p1 = MyClass()
print(p1.x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The examples above are classes and objects in their simplest form, and are not really useful in real life
            applications.
            <br><br>
            To understand the meaning of classes we have to understand the built-in <code>__init__()</code> method.
            <br><br>
            All classes have a method called <code>__init__()</code>, which is always executed when the class is being
            initiated.
            <br><br>
            Use the <code>__init__()</code> method to assign values to object properties, or other operations that are
            necessary to
            do when the object is being created.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

p1 = Person("John", 36)

print(p1.name)
print(p1.age)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>__str__()</code> method controls what should be returned when the class object is represented as a
            string.
            <br><br>
            If the <code>__str__()</code> method is not set, the string representation of the object is returned.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

# Remove this method to see what happens
  def __str__(self):
    return f"{self.name}({self.age})"

p1 = Person("John", 36)

print(p1)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can create your own methods inside objects. Methods in objects are functions that belong to the object.
            <br><br>
            Let us create a method in the Person class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
p1.myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>self</code> parameter is a reference to the current instance of the class, and is used to access
            variables that
            belong to the class.
            <br><br>
            It does not have to be named <code>self</code>, you can call it whatever you like, but it has to be the
            first parameter
            of any function in the class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(mysillyobject, name, age):
    mysillyobject.name = name
    mysillyobject.age = age

  def myfunc(abc):
    print("Hello my name is " + abc.name)

p1 = Person("John", 36)
p1.myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can modify properties on objects like this.
        </div>
        <div class="right-column">
            <pre><code class="language-python">p1.age = 40</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can delete properties on objects by using the <code>del</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">del p1.age</code></pre>
        </div>
    </div>

    <hr>


    <div class="container-row scrollable">
        <div>
            You can delete objects by using the <code>del</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">del p1</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <code>class</code> definitions cannot be empty, but if you for some reason have a <code>class</code>
            definition with no content, put in the <code>pass</code> statement to avoid getting an error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  pass
</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Inheritance</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Inheritance allows us to define a class that inherits all the methods and properties from another class.
            <br><br>
            <b>Parent class</b> is the class being inherited from, also called base class.
            <br><br>
            <b>Child class</b> is the class that inherits from another class, also called derived class.
            <br><br>
            To create a class that inherits the functionality from another class, send the parent class as a parameter
            when creating the child class.
            <br><br>
            Now the Student class has the same properties and methods as the Person class.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Parent class
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

# Child class
class Student(Person):
  pass

x = Student("Mike", "Olsen")
x.printname()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            So far we have created a child class that inherits the properties and methods from its parent.
            <br><br>
            We want to add the <code>__init__()</code> function to the child class.
            <br><br>
            The child's <code>__init__()</code> function overrides the inheritance of the parent's
            <code>__init__()</code> function.
            <br><br>
            To keep the inheritance of the parent's <code>__init__()</code> function, add a call to the parent's
            <code>__init__()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    Person.__init__(self, fname, lname)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            By using the <code>super()</code> function, you do not have to use the name of the parent element, it will
            automatically inherit the methods and properties from its parent.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Add a property called <code>graduationyear</code> to the <code>Student</code> class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)
    self.graduationyear = 2019</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            In the example on the right, the year <code>2019</code> should be a variable, and passed into the
            <code>Student</code> class when creating student objects.
            To do so, add another parameter in the <code>__init__()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

x = Student("Mike", "Olsen", 2019)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Add a method called <code>welcome</code> to the <code>Student</code> class.
            <br><br>
            If you add a method in the child class with the same name as a function in the parent class, the inheritance
            of the parent method will be overridden.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

  def welcome(self):
    print("Welcome", self.firstname, self.lastname, "to the class of", self.graduationyear)</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Iterators</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <div class="container-row scrollable">
        <div>
            An iterator is an object that contains a countable number of values.
            <br><br>
            An iterator is an object that can be iterated upon, meaning that you can traverse through all the values.
            <br><br>
            Technically, in Python, an iterator is an object which implements the iterator protocol, which consist of
            the methods <code>__iter__()</code> and <code>__next__()</code>.
            <br><br>
            Lists, tuples, dictionaries, strings and sets are all iterable objects. They are iterable containers which
            you can get an iterator from.
            <br><br>
            All these objects have a <code>iter()</code> method which is used to get an iterator:
        </div>
        <div class="right-column">
            <pre><code class="language-python">mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))

mystr = "banana"
myit = iter(mystr)

print(next(myit))
print(next(myit))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>for</code> loop actually creates an iterator object and executes the <code>next()</code> method
            for each loop.
        </div>
        <div class="right-column">
            <pre><code class="language-python">mystr = "banana"

for x in mystr:
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To create an object/class as an iterator you have to implement the methods <code>__iter__()</code> and
            <code>__next__()</code> to your
            object.
            <br><br>
            As you have already learned, all classes have a function called <code>__init__()</code>, which allows you to
            do some
            initializing when the object is being created.
            <br><br>
            The <code>__iter__()</code> method acts similar, you can do operations (initializing etc.), but must always
            return the
            iterator object itself.
            <br><br>
            The <code>__next__()</code> method also allows you to do operations, and must return the next item in the
            sequence.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))</code></pre>
        </div>
    </div>

    <hr>


    <div class="container-row scrollable">
        <div>
            The example above would continue forever if you had enough <code>next()</code> statements, or if it was used
            in a <code>for</code> loop.
            <br><br>
            To prevent the iteration from going on forever, we can use the <code>StopIteration</code> statement.
            <br><br>
            In the <code>__next__()</code> method, we can add a terminating condition to raise an error if the iteration
            is done a specified number of times:
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Polymorphism</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The word "polymorphism" means "many forms", and in programming it refers to methods/functions/operators with
            the same name that can be executed on many objects or classes.
            <br><br>
            An example of a Python function that can be used on different objects is the <code>len()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = "Hello World!"
print(len(x))

mytuple = ("apple", "banana", "cherry")
print(len(mytuple))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Polymorphism is often used in Class methods, where we can have multiple classes with the same method name.
            <br><br>
            For example, say we have three classes: <code>Car</code>, <code>Boat</code>, and <code>Plane</code>, and
            they all have a method called <code>move()</code>.
            <br><br>
            Look at the for loop at the end. Because of polymorphism we can execute the same method for all three
            classes.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Car:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Drive!")

class Boat:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Sail!")

class Plane:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang")       #Create a Car object
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747")     #Create a Plane object

for x in (car1, boat1, plane1):
  x.move()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            What about classes with child classes with the same name? Can we use polymorphism there?
            <br><br>
            Yes. If we use the example above and make a parent class called <code>Vehicle</code>, and make
            <code>Car</code>, <code>Boat</code>, <code>Plane</code> child
            classes of <code>Vehicle</code>, the child classes inherits the <code>Vehicle</code> methods, but can
            override them.
            <br><br>
            In the example you can see that the <code>Car</code> class is empty, but it inherits <code>brand</code>,
            <code>model</code>, and <code>move()</code> from Vehicle.
            <br><br>
            The <code>Boat</code> and <code>Plane</code> classes also inherit <code>brand</code>, <code>model</code>,
            and <code>move()</code> from <code>Vehicle</code>, but they both override the <code>move()</code> method.
            <br><br>
            Because of polymorphism we can execute the same method for all classes.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Vehicle:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Move!")

class Car(Vehicle):
  pass

class Boat(Vehicle):
  def move(self):
    print("Sail!")

class Plane(Vehicle):
  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang")       #Create a Car object
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747")     #Create a Plane object

for x in (car1, boat1, plane1):
  print(x.brand)
  print(x.model)
  x.move()</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Modules</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Consider a module to be the same as a code library.
            <br><br>
            A file containing a set of functions you want to include in your application.
            <br><br>
            To create a module just save the code you want in a file with the file extension <code>.py</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Save this code in a file named mymodule.py
def greeting(name):
  print("Hello, " + name)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Now we can use the module we just created, by using the <code>import</code> statement.
            <br><br>
            Note: When using a function from a module, use the syntax: module_name.function_name.
            <br><br>
            There are several built-in modules in Python, which you can import whenever you like.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule

mymodule.greeting("Jonathan")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The module can contain functions, as already described, but also variables of all types.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Add this code to the file mymodule.py
person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Import the module named mymodule, and access the person1 dictionary.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule

a = mymodule.person1["age"]
print(a)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can create an alias when you import a module, by using the <code>as</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule as mx

a = mx.person1["age"]
print(a)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            There is a built-in <code>dir()</code> function to list all the function names (or variable names) in a
            module.
            <br><br>
            The <code>dir()</code> function can be used on all modules, also the ones you create yourself.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import platform

x = dir(platform)
print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can choose to import only parts from a module, by using the <code>from</code> keyword.
            <br><br>
            When importing using the <code>from</code> keyword, do not use the module name when referring to elements in
            the module.
        </div>
        <div class="right-column">
            <pre><code class="language-python">from mymodule import person1

print(person1["age"])</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Dates</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Math</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">JSON</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Regular Expression</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">PIP</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Errors and Exceptions</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            When an error occurs, or exception as we call it, Python will normally stop and generate an error message.
            <br><br>
            These exceptions can be handled using the <code>try</code> statement.
            <br><br>
            Since the try block raises an error, the except block will be executed.
            <br><br>
            Without the try block, the program will crash and raise an error:
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except:
  print("An exception occurred")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can define as many exception blocks as you want, e.g. if you want to execute a special block of code for
            a special kind of error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can use the <code>else</code> keyword to define a block of code to be executed if no errors were raised.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print("Hello")
except:
  print("Something went wrong")
else:
  print("Nothing went wrong")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>finally</code> block, if specified, will be executed regardless if the try block raises an error
            or not.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            This can be useful to close objects and clean up resources.
            <br><br>
            The program can continue, without leaving the file object open.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  f = open("demofile.txt")
  try:
    f.write("Lorum Ipsum")
  except:
    print("Something went wrong when writing to the file")
  finally:
    f.close()
except:
  print("Something went wrong when opening the file")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            As a Python developer you can choose to throw an exception if a condition occurs.
            <br><br>
            To throw (or raise) an exception, use the <code>raise</code> keyword.
            <br><br>
            You can define what kind of error to raise, and the text to print to the user.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = -1

if x < 0:
  raise Exception("Sorry, no numbers below zero")

x = "hello"

if not type(x) is int:
  raise TypeError("Only integers are allowed")</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">User Input</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Virtual Environment</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <!---->
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>

</html>