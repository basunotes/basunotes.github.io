<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes on Python</title>
    <link rel="stylesheet" href="styles/styles.css">
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <span><b>Notes on Python</b></span>

    <p>
        These notes are mainly for me. They may not be completely accurate, but what's most important to me is gaining a
        functional understanding of Python so I can solve problems with it. I only want to gain a deeper understanding
        insofar as it helps clear confusion and debug errors.
    </p>

    <p>
        They are broadly organised as follows:
    <ul>
        <li><a href="#Variables">Variables</a></li>
        <li><a href="#Numbers">Numbers</a></li>
        <li><a href="#Strings">Strings</a></li>
        <li><a href="#Booleans">Booleans</a></li>
        <li><a href="#Lists">Lists</a></li>
        <li><a href="#Tuples">Tuples</a></li>
        <li><a href="#Sets">Sets</a></li>
        <li><a href="#Dictionaries">Dictionaries</a></li>
        <li><a href="#ifMatch">if and match Selections</a></li>
        <li>while and for Loops</li>
        <li>Functions</li>
        <li>Lambdas</li>
        <li>Generators</li>
        <li>Modules</li>
        <li>Classes and OOP</li>
        <li>Exceptions</li>
    </ul>
    </p>

    <span id="Variables"><b>Variables</b></span>

    <p>
        A variable in Python is created when you first assign it a value:
    <pre><code class="language-python">>>> x = 2</code></pre>
    </p>

    <p>
        In the code above, an object is created to represent the value <code>2</code>.
        A variable <code>x</code> is created if it does not already exist.
        The variable <code>x</code> is then linked to this new object <code>2</code>.
        <br>
        A variable itself never has any <i>type</i>; rather, it refers to a particular
        object at any particular point in time. The object it refers to has a type.
        Despite this very important technical detail, it is not uncommon for people to say that <code>x</code>
        is of type integer, as it refers to an object of type integer.
    </p>

    <p>
        To further emphasize the point that variables have no type, consider the code
        following code:
    <pre><code class="language-python">>>> x = 2
>>> x = 2.5
>>> x = "A"</code></pre>
    </p>

    <p>
        With each assignment, we have simply made <code>x</code> refer to a different type of object.
        <br>
        What happens to the object it was previously referencing?
        To be imprecise, if the object is no longer in <i>use</i>, then the space it occupied is <i>reclaimed</i>.
        This is known as <i>garbage collection</i> and we might go into details later.
    </p>

    <p>
        Consider the second line of the following code:
    <pre><code class="language-python">>>> x = 2
>>> y = x</code></pre>
    </p>

    <p>
        Since the variable <code>x</code> is being used here, it is replaced
        by the object it references, namely <code>2</code>.
        A new variable, <code>y</code>, is created and made to reference the same object.
        Therefore, both <code>x</code> and <code>y</code> end up referencing the same object.
        However, there is no <i>link</i> between the two variables.
    </p>

    <p style="font-size: smaller;">
        In the following code, the last assignment makes <code>x</code> reference the integer <code>3</code>, but
        it does not change the object <code>y</code> refers to.
    <pre><code class="language-python">>>> x = 2
>>> y = x
>>> x = x + 1</code></pre>
    </p>

    <p>
        This might be expected behavior for many, but it
        highlights an important fact:
        There is no way to overwrite the value of the object <code>2</code>, as integers are <i>immutable</i> and thus
        can never be changed <i>in place</i>. On the other hand, we have <i>mutable</i> objects, which can be changed in
        place.
        We will discuss them later.
    </p>

    <p>
        Python allows us to perform sequence assignments. It pairs the values
        on the right side of the assignment operator with the variables on the
        left side, assigning the values one at a time. The left side of a sequence assignment must be a sequence (such
        as a tuple or list of targets), while the right side can be any iterable object, not just a sequence. Both sides
        must have the same length.
    <pre><code class="language-python">>>> A, B = 1, 2
>>> A, B
(1, 2)
>>> [A, B] = [3, 4]
>>> A, B
(3, 4)
>>> [a, b, c] = (1, 2, 3) 
>>> a, b, c
(1, 2, 3)
>>> (a, b, c) = 'ABC'
>>> a, c
('A', 'C')</code></pre>
    </p>

    <p>
        In Python, slicing allows you to assign values to specific parts of a sequence. For more flexible unpacking, you
        can use a <i>starred target</i> on the left side of an assignment. This lets you match and capture multiple
        elements from an iterable on the right-hand side. This technique is known as sequence unpacking.
        There are some edge cases that need to be considered. I might discuss them later!
    <pre><code class="language-python">>>> a, *b = [1, 2, 3, 4]
>>> a, b
(1, [2, 3, 4])
>>> *a, b = [1, 2, 3, 4]
>>> a, b
([1, 2, 3], 4)
>>> a, *b, c = [1, 2, 3, 4]
>>> a, b, c
(1, [2, 3], 4)</code></pre>
    </p>

    <p>
        Python allows for multiple-target and augmented assignments:
    <pre><code class="language-python">>>> x = y = z = 1
>>> x, y, z
(1, 1, 1)
>>> x = 'abc'
>>> x += 'd'
>>> x
'abcd'</code></pre>
    </p>

    <!--Bookmarks-->

    <p>
        It is good practice to give variables descriptive names, unlike in mathematics.
        Moreover, there are certain strict rules that need to be followed; otherwise, you will get a
        syntax error.
    <ul>
        <li>A variable name must start with a letter or the underscore character</li>
        <li>A variable name cannot start with a number</li>
        <li>A variable name can only contain alphanumeric characters and underscores</li>
        <li>Variable names are case-sensitive</li>
        <li>A variable cannot be any of the Python keywords</li>
    </ul>
    </p>

    <p>
        If you want to give a variable a name with more than one word, there are several naming
        conventions to make it more readable.
        We will use the snake case: <code>word1_word2</code>.
    </p>

    <hr>

    <span id="Numbers"><b>Numbers</b></span>

    <p>
        Python supports the usual numeric types: integers and floating-point numbers.
        It also provides more advanced numeric programming support, which we will explore later.
    </p>

    <p>
        Arithmetic operators are used to perform common mathematical operations. These operators include: Addition
        (<code>+</code>), Subtraction (<code>-</code>), Multiplication (<code>*</code>), Division (<code>/</code>),
        Modulus
        (<code>%</code>), Exponentiation (<code>**</code>), and Floor Division (<code>//</code>).
    </p>

    <p>
        If an expression contains more than one operator, Python uses precedence rules to determine which operation to
        perform first.
        Many of these rules are similar to those in mathematics. For example, multiplication takes precedence over
        addition.
        Expressions within parentheses are evaluated first.
    <pre><code class="language-python">>>> 2 * 3 + 5
11
>>> 2 * (3 + 5)
16</code></pre>
    </p>

    <p>
        If an expression consists of different numeric types, Python converts all the operands up to the type of the
        most complex operand in the expression.
        In the following example, the integer is promoted to a floating-point number.
    <pre><code class="language-python">>>> 2.5 + 3 
5.5</code></pre>
    </p>

    <p>
        In Python, you can represent numbers not only in decimal (base 10), but also in hexadecimal (base 16), octal
        (base 8), and binary (base 2) using specific prefixes:
    <pre><code class="language-python">>>> 0xA, 0o11, 0b110
(10, 9, 6)</code></pre>
    </p>

    <p>
        To convert decimal integers to these other bases, you can use Pythonâ€™s built-in functions:
    <pre><code class="language-python">>>> hex(10), oct(9), bin(6)
('0xa', '0o11', '0b110')</code></pre>
    </p>

    <p>These functions return strings formatted with the appropriate base prefix. To convert a string representation of
        a number back into an integer, use the built-in <code>int</code> function and specify the base:
    <pre><code class="language-python">>>> int('0xA', 16)
10</code></pre>
    </p>

    <p>
        A large value such as 9,999,999 is easier to read when written with commas to group digits. As of Python 3.6,
        numeric literals in Python can contain underscores to group digits together, making them easier to read. These
        underscores do not change the value of the literal.
    <pre><code class="language-python">>>> 9_999_999
9999999</code></pre>
    </p>

    <hr>

    <span id="Strings"><b>Strings</b></span>

    <p>
        Python strings are categorized as immutable sequences, meaning that the characters they contain have a
        left-to-right positional order and cannot be changed in place.
        <br><br>
        Escape sequences let us embed characters that cannot be easily inserted into a string literal. The character
        <code>\</code>,
        along with one or more characters following it in the string literal, is replaced with a single character in the
        resulting string object.
    <pre><code class="language-python">>>> x = 'a\nb'
>>> print(x)
a
b</code></pre>
    </p>

    <p>
        File paths usually contain backslashes. This can cause problems when you try to open the file, as Python
        interprets those backslashes as escape characters. To avoid this problem, you can use the letter <code>r</code>
        before the
        string to tell Python to treat the backslashes as literal characters.
    <pre><code class="language-python">>>> path = r"C:\new\test.dat"</code></pre>
    </p>

    <p>
        You can use Pythonâ€™s built-in <code>ord</code> function to convert a single character into its corresponding
        Unicode code point (an integer).
    <pre><code class="language-python">>>> ord('A')
65</code></pre>
    </p>

    <p>
        To do the reverse, that is, convert a Unicode code point back to a character, use the <code>chr</code> function.
    <pre><code class="language-python">>>> chr(65)
'A'</code></pre>
    </p>

    <p>
        You can concatenate strings using the <code>+</code> operator and repeat them
        using the <code>*</code> operator. The meaning of an operator depends on the types of objects being processed.
        This is known as polymorphism, which we will discuss later.
        However, Python does not allow combining numbers and strings using the <code>+</code> operator; doing so will
        result in a
        <code>TypeError</code>.
    </p>

    <p>
        Slicing lets you get a part of a sequence, like a string, using two numbers separated by a colon: start:end.
        The first number is the starting index (included), and the second is the ending index (not included).
        Python returns a new object with the items in that range.
        If you leave out the start index, it defaults to 0. If you leave out the end index, it defaults to the length of
        the sequence.
    <pre><code class="language-python">>>> x = 'abcdef'
>>> x[0], x[-2], x[1:3], x[1:], x[:-1]
('a', 'e', 'bc', 'bcdef', 'abcde')</code></pre>
    <p>

    <p>
        You can also add a third number, like this: start:end:step. This is called the step or stride. By default, the
        step is 1 (go one item at a time).
        But you can use it to skip items (e.g., every other item) or even go backward by using a negative step.
    <pre><code class="language-python">>>> x = 'abcdef'
>>> x[::2]
'ace'
>>> x[::-1]
'fedcba'</code></pre>
    </p>

    <p>
        In the slicing expression <code>x[::-1]</code>, the first two bounds can be
        thought of as defaulting to <code>len(x)-1</code> and <code>-1</code>.
    </p>


    <p>
        You can get an IndexError when you try to access a character in a string using its positional index if the index
        does not exist. But with slicing, out-of-range indexes are automatically adjusted to stay within bounds.
    <pre><code class="language-python">>>> x = 'abc'
>>> x[1:100]
'bc'</code></pre>
    </p>

    <p>
        Since strings are an immutable sequence, they cannot be changed in place by assigning to an index.
        This results in a <code>TypeError: 'str' object does not support item assignment</code>.
    <pre><code class="language-python">>>> x = 'abc'
>>> x[0] = 'd'</code></pre>
    </p>


    <p>
        To modify a string in Python, you generally need to create a new string using techniques such as concatenation
        or slicing, and then assign the result back to the original variable. Since strings are immutable, any operation
        that appears to modify a string actually returns a new string object. String methods also generate new string
        objects. If you want to retain these new strings, you need to assign them to variables. Python automatically
        garbage-collects old, unused string objects.
        <br><br>
        Methods are functions that are associated with and operate on objects. Consider the following method call
        expression:
    <pre class="plain"><code class="plain">object.method(arguments)</code></pre>
    </p>

    <p>
        This expression is evaluated from left to right. Python retrieves the method associated with the object, then
        calls it, passing in both the object and the provided arguments. If the method returns a result, that result
        becomes the value of the entire method-call expression.
    </p>

    <p>
        Here are some of the most frequently used string methods. I have not covered the edge cases, so make sure to be
        aware of them to avoid unexpected behavior.
    </p>

    <p>
        The <code>upper</code> method returns the strings in upper case:
    <pre><code class="language-python">>>> x = 'abc'
>>> x.upper()
'ABC'</code></pre>
    </p>


    <p>
        The <code>lower</code> method returns the string in lower case:
    <pre><code class="language-python">>>> x = 'ABC'
>>> x.lower()
'abc'</code></pre>
    </p>

    <p>
        The <code>strip</code> method removes any whitespace from the beginning or the end of a string:
    <pre><code class="language-python">>>> x = 'abc '
>>> x.strip()
'abc'</code></pre>
    </p>

    <p>
        The <code>replace</code> method replaces a substring with another string:
    <pre><code class="language-python">>>> x = 'abc'
>>> x.replace('a', 'd')
'dbc'</code></pre>
    </p>

    <p>
        The <code>split</code> method divides a string into a list of substrings based on a specified separator:
    <pre><code class="language-python">>>> x = "1, 2, 3"
>>> x.split(",")
['1', ' 2', ' 3']</code></pre>
    </p>

    <p>
        F-strings were introduced in Python 3.6 and allow for clean, concise string formatting.
        To specify a string as an f-string, simply put <code>f</code> in front of the string literal,
        and use curly brackets <code>{}</code> as placeholders:
    <pre><code class="language-python">>>> x = 'd'
>>> y = f'abc{x}'
>>> y
'abcd'</code></pre>
    </p>

    <p>
        The expressions inside <code>{}</code> are evaluated at runtime, using the current values of the variables or
        expressions they contain.
        A placeholder can include variables, operations, function calls, and formatting modifiers.
    <pre><code class="language-python">>>> x = 'd'
>>> f'abc{x.upper()}'
'abcD'
>>> x = 2
>>> f'{x:.2f}'
'2.00'
>>> f'The result is {2 * 5}'
'The result is 10'</code></pre>
    </p>

    <hr>

    <span id="Booleans"><b>Booleans</b></span>

    <p>
        Python comes with Booleans with predefined <code>True</code> and
        <code>False</code> objects that are essentially just the integers 1 and 0
        with custom display logic.
    <pre><code class="language-python">>>> True + 1
2</code></pre>
    </p>
    <p>
        It also has a special placeholder object called <code>None</code>, which is commonly
        used to initialize names and objects and designate the absence of a result in functions.
    </p>

    <p>
        Python provides a <code>bool</code> built-in function that can be used to extract the Boolean
        value of an object. You can use this to explicitly check if an object is true, that is,
        nonzero or nonempty.
    <pre><code class="language-python">>>> bool(1)
True
>>> bool(0)
False
>>> bool('abc')
True
>>> bool('')
False</code></pre>
    </p>

    <p>
    <p>
        Comparison operators are used to compare values. For numbers, they work exactly as you'd expect. These operators
        include: Equal to (<code>==</code>), Not equal to (<code>!=</code>), Less than (<code>&lt;</code>), Greater than
        (<code>&gt;</code>), Less than or equal to (<code>&lt;=</code>), and
        Greater than or equal to (<code>&gt;=</code>).
    <pre><code class="language-python">>>> 10 > 9
True
>>> 10 == 9
False
>>> 10 &lt; 9
False</code></pre>
    </p>

    <p>
        Consider the following code. The result is <code>False</code> because floating-point numbers in Python cannot
        represent decimal values exactly
        due to precision limitations.
    <pre><code class="language-python">>>> 1.1 + 2.2 == 3.3
False
>>> 1.1 + 2.2
3.3000000000000003
</code></pre>
    </p>

    <p>
        To handle this issue, you can use the <code>isclose()</code> method from the <code>math</code> module, which
        allows
        you to compare floating-point numbers with a tolerance for small errors:
    <pre><code class="language-python">>>> import math
>>> math.isclose(1.1 + 2.2, 3.3)
True
</code></pre>
    </p>

    <p>
        Alternatively, the <code>Decimal</code> class from the <code>decimal</code> module can be used for precise
        decimal
        arithmetic. It provides an exact representation of decimal numbers, avoiding the rounding issues associated with
        floats:
    <pre><code class="language-python">>>> from decimal import Decimal
>>> Decimal('1.1') + Decimal('2.2') == Decimal('3.3')
True
</code></pre>
    </p>


    <p>
        When comparing different types, Python will attempt to convert values to a common type before making the
        comparison. For example, comparing an integer with a float will
        convert the integer to a float before performing the comparison.
    </p>

    <p>
        Python has three Boolean operators: <code>and</code>, <code>or</code>, and <code>not</code>.
        These operators always return an object, either the object on the left side of the operator
        or the object on the right.
        The <code>and</code> operator returns the first false operand or the last operand if both are true.
        The <code>or</code> operator returns the first true operand or the last if both are false.
        The <code>not</code> operator inverts the truth value.
    <pre><code class="language-python">>>> {} and []
{}
>>> {} and 4
{}
>>> 3 and 4
4
>>> 3 or 4
3
>>> {} or []
[]
>>> not 3
False</code></pre>
    </p>

    <p>
        The net result of all this is that you get a value that is logically true or false when tested in an
        <code>if</code> or <code>while</code> statement, according to the normal definition of <code>or</code> and
        <code>and</code>.
    </p>

    <p>
        Python allows for chained comparisons. For example, the expression <code>X &lt; Y &lt; Z</code> is equivalent to
        <code>X &lt; Y and Y &lt; Z</code>. It's best to avoid this and be as explicit as possible.
    </p>

    <p>
        In Python, there are two primary ways to compare objects: the <code>==</code> operator and the <code>is</code>
        operator. The <code>==</code> operator
        tests for equality, checking whether the values of two objects are the same by comparing all parts of compound
        objects and their nested components, from left to right, until a difference is found. On the other hand, the
        <code>is</code>
        operator tests for object identity, verifying whether two names point to the exact same object in memory,
        essentially checking if they occupy the same address.
    <pre><code class="language-python">>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 3)]
>>> L1 == L2, L1 is L2
(True, False)
>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 2)]
>>> L1 &lt; L2
False</code></pre>
    </p>

    <p>
        You need to be careful, as Python internally caches and reuses certain objects
        for optimization purposes. For example:
    <pre><code class="language-python">>>> x = 256
>>> y = 256
>>> x is y
True</code></pre>
    </p>

    <p>
        The <code>getrefcount</code>function can help explore this behavior by showing how many references an object
        has.
    </p>

    <hr>

    <span id="Lists"><b>Lists</b></span>



    <p>
        Lists are sequences and support many of the same operations as strings.
        <br>
        The <code>+</code> and <code>*</code> operators represent concatenation and repetition, respectively.
        Indexing and slicing work the same way.
    </p>

    <p>
        However, lists are mutable, meaning they support operations that modify
        a list object in place. To illustrate this point, consider the following code:
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = x
>>> x[0] = 4
>>> y
[4, 2, 3]</code></pre>
    </p>

    <p>
        One might expect that the last assignment does not affect <code>y</code>, as it still refers to the old object.
        This is not the case. We have changed a component of the object <code>x</code> refers to. This overwrites the
        value in place, so it affects <code>y</code> because it refers to the same object.
        <br><br>
        If you don't want this, you can make a copy of the object. There are multiple ways to do this, one of which is:
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = x[:]
>>> x[0] = 4
>>> y
[1, 2, 3]</code></pre>
    </p>

    <p> When using a list, you can modify its contents by assigning a new value to a specific item or to a range (slice)
        of items. The length of the sequence being assigned does not need to match the length of the slice being
        replaced. Slice assignment can be used to replace, expand, or shrink the subject list.
    <pre><code class="language-python">>>> x = [1, 2, 3] 
>>> x[1:2] = [4, 5] 
>>> x 
[1, 4, 5, 3] 
>>> x[1:1] = [6, 7] 
>>> x 
[1, 6, 7, 4, 5, 3] 
>>> x[1:2] = [] 
>>> x 
[1, 7, 4, 5, 3]</code></pre>
    </p>

    <p>
        Like strings, Python list objects also support type-specific method calls,
        most of which modify the list itself.
    </p>

    <p>
        The <code>insert</code> method can be used to insert items at a specified location without replacing any of the
        existing items.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> x.insert(2, 5)
>>> x
[1, 2, 5, 3, 4]</code></pre>
    </p>

    <p>
        To add an item to the end of the list, use the <code>append</code> method.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> x.append(4)
>>> x
[1, 2, 3, 4]</code></pre>
    </p>

    <p>
        To append elements from another list to the current list, use the <code>extend</code> method.
        The elements will be added to the end of the list.
        The <code>extend</code> method does not have to append lists, you can add any iterable object.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = [4, 5]
>>> x.extend(y)
>>> x
[1, 2, 3, 4, 5]</code></pre>
    </p>

    <p>
        The <code>remove</code> method removes the specified item.
        If there are more than one item with the specified value, then the method removes the first occurrence.
    <pre><code class="language-python">>>> x = [1, 1, 2, 3]
>>> x.remove(1)
>>> x
[1, 2, 3]</code></pre>
    </p>

    <p>
        The <code>pop</code> method removes and returns the item from the specified index.
        If no index is specified, then it removes the last item.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> x.pop(2)
3
>>> x
[1, 2, 4]
>>> x.pop()
4
>>> x
[1, 2]</code></pre>
    </p>

    <p>
        The <code>del</code> keyword also removes item from specied index. The syntax is different.
        You can use it also to delete the entire list.
    <pre><code class="language-python">>>> x = [1, 2, 3, 4]
>>> del x[2]
>>> x
[1, 2, 4]
>>> del x</code></pre>
    </p>

    <p>
        The <code>clear</code> method empties the list but it does not delete it.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> x.clear()
>>> x
[]</code></pre>
    </p>

    <p>
        List objects have a <code>sort</code> method that sorts the list alphanumerically, ascending by default.
        Just make sure that the items are of the same data type.
        <br>
        To sort descending use the keyword argument <code>reverse = True</code>.
        Alternatively, one can use the <code>reverse</code> method.
    <pre><code class="language-python">>>> x = [3, 1, 2]
>>> x.sort()
>>> x
[1, 2, 3]
>>> x.sort(reverse = True)
>>> x
[3, 2, 1]
>>> x.reverse()
>>> x
[1, 2, 3]</code></pre>
    </p>

    <p>
        You can also sort based on a function by using the keyword argument <code>key = function</code>.
        The function will return a value for each item in list based on which the list will be sorted.
        The <code>sort</code> method is case-sensitive. To avoid unexpect results you can use <code>str.lower</code>
        as a key function.
    <pre><code class="language-python">>>> def myfunc(n):
...     return abs(n - 50)
... 
>>> x = [100, 50, 65, 82, 23]
>>> x.sort(key = myfunc)
>>> x
[50, 65, 23, 82, 100]</code></pre>
    </p>

    <p>
        Instead of using slice syntax, you can also use the <code>copy</code> method or the
        <code>List</code> constructor.
    <pre><code class="language-python">>>> x = [1, 2, 3]
>>> y = list(x)
>>> z = x.copy()
>>> y, z
([1, 2, 3], [1, 2, 3])</code></pre>
    </p>

    <hr>

    <span id="Tuples"><b>Tuples</b></span>

    <p>
        Tuples, like strings, are immutable sequences. There are certain
        peculiarities one must be aware of when working with them. For example,
        if you want a single-item tuple, you need to add a trailing comma:
    <pre><code class="language-python">>>> x = (2)
>>> x
2
>>> x = (2,)
>>> x
(2,)</code></pre>
    </p>

    <p>
        Python allows you to omit the opening and closing round brackets for a tuple
        where it is not ambiguous to do so:
    <pre><code class="language-python">>>> x = 2, 3, 4
>>> x
(2, 3, 4)</code></pre>
    </p>

    <p>
        Tuples don't provide the same methods as strings, lists, or
        dictionaries. For example, there is no built-in <code>append</code> method.
        A workaround for modifying a tuple is to convert it into a list, make your changes,
        and then convert it back into a tuple using the <code>tuple</code> constructor.
        The immutability of tuples provides some integrity; you can be sure that
        a tuple won't be changed elsewhere in a program unintentionally.
    </p>

    <hr>

    <span id="Sets"><b>Sets</b></span>

    <p>Python sets are unordered collections of unique and immutable (hashable) elements. Unlike lists or tuples, sets
        do not allow duplicates and do not maintain any order. You can create a set using the built-in <code>set</code>
        function
        with any iterable, or with curly brace (<code>{}</code>) literals.
    <pre><code class="language-python">>>> A = set('abc')
>>> B = {'d', 'e', 'f'}
>>> A, B
({'c', 'a', 'b'}, {'e', 'd', 'f'})</code></pre>
    </p>

    <p>
        Sets support fast membership testing and standard set operations like union, intersection, difference, subset
        and superset checks:
    <pre><code class="language-python">>>> A = {1, 2, 3, 4}
>>> B = {2, 4, 5, 6}
>>> A & B
{2, 4}
>>> A | B
{1, 2, 3, 4, 5, 6}
>>> A - B
{1, 3}
>>> A > B
False</code></pre>
    </p>

    <p>
        Sets are especially handy for eliminating duplicates, comparing collections regardless of order, or checking
        what's missing or extra:
    <pre><code class="language-python">>>> list(set([1, 2, 2, 3, 1]))
[1, 2, 3]
>>> set('learn') - set('ear')
{'n', 'l'}
>>> set('note') == set('tone')
True</code></pre>
    </p>

    <p>
        Regular sets are mutable, meaning you can add or remove items using methods like <code>add</code> and
        <code>remove</code>.
        However, the elements themselves must be immutable. You can use the <code>update</code> method to add items
        from an iterable object.
    </p>

    <hr>

    <span id="Dictionaries"><b>Dictionaries</b></span>

    <p>Dictionaries are key-based collections of objects. Items are stored and retrieved using keys, rather than by
        positional index as in lists. Internally, dictionaries are implemented as hash tables.
    </p>

    <p> When you assign a new key to a dictionary, a new key-value pair is added to the dictionary. This differs from
        lists, where you can only assign values to existing indices. Dictionary keys are not limited to strings; any
        immutable object (such as numbers, strings, or tuples) can be used as a key.
    </p>

    <p>As of Python 3.7, dictionaries preserve the insertion order of keys as an implementation detail, and this
        behavior became an official part of the Python language specification in Python 3.8.
    <pre><code class="language-python">>>> D = {'a': 1, 'b': 2, 3: 'c'}
>>> D
{'a': 1, 'b': 2, 3: 'c'}
>>> D['e'] = 4
>>> D
{'a': 1, 'b': 2, 3: 'c', 'e': 4}
>>> D = {'a' : 1, 'a': 2}
>>> D
{'a': 2}</code></pre>
    </p>

    <p>
        You can build dictionaries using the <code>dict</code> constructor.
    <pre><code class="language-python">>>> x = dict(a = 1, b = 2)
>>> x
{'a': 1, 'b': 2}</code></pre>
    </p>

    <p>
        Dictionary methods <code>keys</code>, <code>values</code>, and <code>items</code> return iterable objects
        containing keys, values, and (key,
        value) pairs, respectively, which can be used in loops or converted to lists for display. Any changes done to
        the dictionary will be
        reflected accordingly.
    <pre><code class="language-python">>>> x = {'a' : 1, 'b': 2, 'c': 3}
>>> list(x.keys())
['a', 'b', 'c']
>>> list(x.values())
[1, 2, 3]
>>> list(x.items())
[('a', 1), ('b', 2), ('c', 3)]
>>> x['d'] = 4
>>> list(x.keys())
['a', 'b', 'c', 'd']</code></pre>
    </p>

    <p>
        Fetching a nonexistent key is normally an error, but the <code>get</code>
        method returns a default value, <code>None</code>, or a passed-in default if the key
        doesn't exist.
    <pre><code class="language-python">>>> D = {'a' : 1}
>>> D.get('b')
>>> D.get('b', 2)
2</code></pre>
    </p>

    <p>
        The <code>update</code> method merges the keys and values of one
        dictionary into another, both adding new entries for new keys and blindly
        overwriting values of existing keys if there's a clash. The dictionary's <code>pop</code>
        method deletes a key from the dictionary and returns the value it had, similar to other
        <code>pop</code> methods.
    <pre><code class="language-python">>>> D = {'a': 1, 'b': 2}
>>> D.update({'c': 3})
>>> D
{'a': 1, 'b': 2, 'c': 3}
>>> D.pop('a')
1
>>> D
{'b': 2, 'c': 3}</code></pre>
    </p>

    <hr>

    <span id="ifMatch"><b>if and Match Selections</b></span>

    <p>
        All Python compound statements, statements that have other statements nested inside them, follow the same
        general pattern of a header line terminated in a colon, followed by a nested block of code usually indented
        underneath the header line, like this:
    <pre style="background-color: #f0f0f0 !important;"><code style="font-size: smaller;">Header line:
	Nested statement block</code></pre>
    </p>

    <p>
        Python relies on indentation (whitespace at the beginning of a line) to define scope in the code. Other
        programming languages often use curly brackets for this purpose. Consider the following code: Python evaluates
        the condition inside an <code>if</code> statement and runs the appropriate code based on whether the condition
        is <code>True</code> or <code>False</code>.
    <pre><code class="language-python">>>> a = 33
>>> b = 200
>>> if b > 0:
...     print('b is greater than a')
... 
b is greater than a</code></pre>
    </p>


    <!--Bookmark-->

    <br><br>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you want to specify the data type of a variable then this can be done with casting.
        </div>
        <div class="right-column">
            <pre><code class="language-python">age = int(23)
weight = float(65) # weight will be 65.0
category = str(5) # category will be "5"</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The data type of a variable can be found using the <code>type()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">print(type(age)) # Output: &ltclass 'int'&gt
print(type(weight)) # Output: &ltclass 'float'&gt
print(type(category)) # Output: &ltclass 'str'&gt</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Strings</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Using triple single or double quotes it is possible to assign a multiline string to a variable.
        </div>
        <div class="right-column">
            <pre><code class="language-python">text1 = """This is a
multiline sentence."""</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Since strings are arrays, we can loop through the characters of a string using a
            <code>for</code> loop.
        </div>
        <div class="right-column">
            <pre><code class="language-python">for x in "apple":
    print(x)
</code></pre>
        </div>
    </div>


    <hr>

    <div class="container-row scrollable">
        <div>
            To check if certain characters are present or not present in a string,
            we can use the keyword <code>in</code> or <code>not in</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">text = "Hello World"
print("World" in text) # Output: True
print(" World" in text) # Output: True
print("world" in text) # Output: False
print("Hi" not in text) # Output: True</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If there is a condition inside an <code>if</code> statement, Python evaluates the condition and
            runs the appropriate code based on whether the condition is <code>True</code> or <code>False</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 10
b = 9

if b > a:
  print("b is greater than a")
else:
  print("b is not greater than a")</code></pre>
        </div>
    </div>


    <hr>

    <div class="container-row scrollable">
        <div>
            A object made from a class with <code>__len__</code> function that
            returns <code>0</code> or <code>False</code> will be evaluated to <code>False</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class myclass():
  def __len__(self):
    return 0

myobj = myclass()
print(bool(myobj))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The built-in function <code>isinstance()</code> returns a boolean value.
            It is used to determine whether an object is of certain data type.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x  = 2
print(isinstance(x, int))</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Membership Operators</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Membership operators are used to test if a sequence is presented in an object.
        </div>
        <div class="right-column">
            <div class="scrollable">
                <table class="three-columns">
                    <tr style="font-weight: bold;">
                        <td>Operator</td>
                        <td>Description</td>
                        <td>Example</td>
                    </tr>
                    <tr>
                        <td><code>in</code></td>
                        <td>Returns <code>True</code> if a sequence with the specified value
                            is present in the object</td>
                        <td><code>x in y</code></td>
                    </tr>
                    <tr>
                        <td><code>not in</code></td>
                        <td>Returns <code>True</code> if a sequence with the specified value
                            is not present in the object</td>
                        <td><code>x in y</code></td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Lists</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <span style="font-weight: bold;">List Comprehension</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <span style="font-weight: bold;">Dictionaries</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To determine if a specified key is present in a dictionary use the <code>in</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Conditionals</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            The <code>elif</code> keyword is Python's way of saying "if the previous conditions were not true, then try
            this condition".
            <br><br>
            You can have mutltiple elif conditions.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 33
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>else</code> keyword catches anything which isn't caught by the preceding conditions.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 200
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")
else:
  print("a is greater than b")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you have only one statement to execute, you can put it on the same line as the if statement.
        </div>
        <div class="right-column">
            <pre><code class="language-python">if a > b: print("a is greater than b")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you have only one statement to execute, one for if, and one for else, you can put it all on the same
            line:
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 2
b = 330
print("A") if a > b else print("B")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can also have multiple else statements on the same line.
            <br><br>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 330
b = 330
print("A") if a > b else print("=") if a == b else print("B")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>and</code> keyword is a logical operator, and is used to combine conditional statements.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 200
b = 33
c = 500
if a > b and c > a:
  print("Both conditions are True")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>or</code> keyword is a logical operator, and is used to combine conditional statements.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 200
b = 33
c = 500
if a > b or a > c:
  print("At least one of the conditions is True")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>not</code> keyword is a logical operator, and is used to reverse the result of the conditional
            statement.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 33
b = 200
if not a > b:
  print("a is NOT greater than b")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can have <code>if</code> statements inside <code>if</code> statements, this is called nested
            <code>if</code> statements.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = 41

if x > 10:
  print("Above ten,")
  if x > 20:
    print("and also above 20!")
  else:
    print("but not above 20.")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <code>if</code> statements cannot be empty, but if you for some reason have an <code>if</code> statement
            with no content, put in the pass statement to avoid getting an error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">a = 33
b = 200

if b > a:
  pass</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Match</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            The <code>match</code> statement is used to perform different actions based on different conditions.
            <br><br>
            Instead of writing many <code>if..else</code> statements, you can use the <code>match</code> statement.
            <br><br>
            The <code>match</code> statement selects one of many code blocks to be executed.
            <br><br>
            This is how it works: The match expression is evaluated once. The value of the expression is compared with
            the values of each case.
            If there is a match, the associated block of code is executed.
        </div>
        <div class="right-column">
            <pre><code class="language-python">day = 4
match day:
  case 1:
    print("Monday")
  case 2:
    print("Tuesday")
  case 3:
    print("Wednesday")
  case 4:
    print("Thursday")
  case 5:
    print("Friday")
  case 6:
    print("Saturday")
  case 7:
    print("Sunday")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Use the underscore character <code>_</code> as the last case value if you want a code block to execute when
            there are not other matches.
            <br><br>
            The value <code>_</code> will always match, so it is important to place it as the last <code>case</code> to
            make it
            behave as a default <code>case</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">day = 4
match day:
  case 6:
    print("Today is Saturday")
  case 7:
    print("Today is Sunday")
  case _:
    print("Looking forward to the Weekend")</code></pre>
        </div>
    </div>

    <hr>


    <div class="container-row scrollable">
        <div>
            Use the pipe character <code>|</code> as an or operator in the <code>case</code> evaluation to check for
            more than one value match in one <code>case</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">day = 4
match day:
  case 1 | 2 | 3 | 4 | 5:
    print("Today is a weekday")
  case 6 | 7:
    print("I love weekends!")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can add <code>if</code> statements in the case evaluation as an extra condition-check.
        </div>
        <div class="right-column">
            <pre><code class="language-python">month = 5
day = 4
match day:
  case 1 | 2 | 3 | 4 | 5 if month == 4:
    print("A weekday in April")
  case 1 | 2 | 3 | 4 | 5 if month == 5:
    print("A weekday in May")
  case _:
    print("No match")</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">While Loops</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            With the <code>while</code> loop we can execute a set of statements as long as a condition is true.
            <br><br>
            Remember to increment <code>i</code>, or else the loop will continue forever.
            <br><br>
            The <code>while</code> loop requires relevant variables to be ready, in this example we need to define an
            indexing variable, <code>i</code>, which we set to 1.
        </div>
        <div class="right-column">
            <pre><code class="language-python">i = 1
while i &lt 6:
  print(i)
  i += 1</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            With the <code>break</code> statement we can stop the loop even if the while condition is true.
        </div>
        <div class="right-column">
            <pre><code class="language-python">i = 1
while i &lt 6:
  print(i)
  if i == 3:
    break
  i += 1</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            With the <code>continue</code> statement we can stop the current iteration, and continue with the next.
        </div>
        <div class="right-column">
            <pre><code class="language-python">i = 0
while i &lt 6:
  i += 1
  if i == 3:
    continue
  print(i)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            With the <code>else</code> statement we can run a block of code once when the condition no longer is true.
        </div>
        <div class="right-column">
            <pre><code class="language-python">i = 1
while i &lt 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">For Loops</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            A <code>for</code> loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary,
            a set, or a
            string).
            <br><br>
            This is less like the <code>for</code> keyword in other programming languages, and works more like an
            iterator method as
            found in other object-orientated programming languages.
            <br><br>
            With the <code>for</code> loop we can execute a set of statements, once for each item in a list, tuple, set
            etc.
            <br><br>
            The <code>for</code> loop does not require an indexing variable to set beforehand.
        </div>
        <div class="right-column">
            <pre><code class="language-python">fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)

for x in "banana":
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            With the <code>break</code> statement we can stop the loop before it has looped through all the items.
        </div>
        <div class="right-column">
            <pre><code class="language-python">fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            With the <code>continue</code> statement we can stop the current iteration of the loop, and continue with
            the next.
        </div>
        <div class="right-column">
            <pre><code class="language-python">fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To loop through a set of code a specified number of times, we can use the <code>range()</code> function.
            <br><br>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python">for x in range(6):
  print(x)

for x in range(2, 6):
  print(x)

for x in range(2, 30, 3):
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>else</code> keyword in a <code>for</code> loop specifies a block of code to be executed when the
            loop is finished.
            <br><br>
            The <code>else</code> block will NOT be executed if the loop is stopped by a <code>break</code> statement.
        </div>
        <div class="right-column">
            <pre><code class="language-python">for x in range(6):
  print(x)
else:
  print("Finally finished!")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            A nested loop is a loop inside a loop.
            <br><br>
            The "inner loop" will be executed one time for each iteration of the "outer loop":
        </div>
        <div class="right-column">
            <pre><code class="language-python">adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]

for x in adj:
  for y in fruits:
    print(x, y)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <code>for</code> loops cannot be empty, but if you for some reason have a <code>for</code> loop with no
            content, put in the <code>pass</code> statement to avoid getting an error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">for x in [0, 1, 2]:
  pass</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Functions</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            A function is a block of code which only runs when it is called.
            <br><br>
            You can pass data, known as parameters, into a function.
            <br><br>
            A function can return data as a result.
            <br><br>
            In Python a function is defined using the <code>def</code> keyword.
            <br>
            To call a function, use the function name followed by parenthesis.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function():
  print("Hello from a function")

my_function()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Information can be passed into functions as arguments.
            <br><br>
            Arguments are specified after the function name, inside the parentheses. You can add as many arguments as
            you want, just separate them with a comma.
            <br><br>
            Arguments are often shortened to args in Python documentations.
            <br><br>
            <i>Detials later! (Arguments and Parameters. Errors.)</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you do not know how many arguments that will be passed into your function, add a <code>*</code> before
            the parameter name in the function definition.
            <br><br>
            This way the function will receive a tuple of arguments, and can access the items accordingly.
            <br><br>
            Arbitrary Arguments are often shortened to *args in Python documentations.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can also send arguments with the key = value syntax.
            <br><br>
            This way the order of the arguments does not matter.
            <br><br>
            he phrase Keyword Arguments are often shortened to kwargs in Python documentations.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(child3, child2, child1):
  print("The youngest child is " + child3)

my_function(child1 = "Emil", child2 = "Tobias", child3 = "Linus")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you do not know how many keyword arguments that will be passed into your function, add two asterisk:
            <code>**</code> before the parameter name in the function definition.
            <br><br>
            This way the function will receive a dictionary of arguments, and can access the items accordingly.
            <br><br>
            Arbitrary Kword Arguments are often shortened to **kwargs in Python documentations.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(**kid):
  print("His last name is " + kid["lname"])

my_function(fname = "Tobias", lname = "Refsnes")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The example on the right shows how to use a default parameter value.
            <br><br>
            If we call the function without argument, it uses the default value.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can send any data types of argument to a function (string, number, list, dictionary etc.), and it will
            be treated as the same data type inside the function.
            <br><br>
            E.g. if you send a List as an argument, it will still be a List when it reaches the function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To let a function return a value, use the <code>return</code> statement.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(x):
  return 5 * x

print(my_function(3))
print(my_function(5))
print(my_function(9))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <code>function</code> definitions cannot be empty, but if you for some reason have a <code>function</code>
            definition with no content,
            put in the <code>pass</code> statement to avoid getting an error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunction():
  pass</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can specify that a function can have ONLY positional arguments.
            <br><br>
            To specify that a function can have only positional arguments, add <code>, /</code> after the arguments.
            <br><br>
            Without the <code>, / </code> you are actually allowed to use keyword arguments even if the function expects
            positional arguments.
            <br><br>
            But when adding the <code>, /</code> you will get an error if you try to send a keyword argument.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(x, /):
  print(x)

my_function(3)

def my_function(x):
  print(x)

my_function(x = 3)

def my_function(x, /):
  print(x)

my_function(x = 3)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To specify that a function can have only keyword arguments, add <code>*</code>, before the arguments.
            <br><br>
            You will get an error if you try to send a positional argument.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(*, x):
  print(x)

my_function(x = 3)

def my_function(*, x):
  print(x)

my_function(3)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can combine the two argument types in the same function.
            <br><br>
            Any argument before the <code>/ ,</code> are positional-only, and any argument after the <code>*</code>, are
            keyword-only.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def my_function(a, b, /, *, c, d):
  print(a + b + c + d)

my_function(5, 6, c = 7, d = 8)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Recursion.
            <br><br>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Lambda</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            A lambda function is a small anonymous function.
            <br><br>
            A lambda function can take any number of arguments, but can only have one expression.
            <br><br>
            Syntax: <br>
            <code>lambda arguments : expression</code>
            <br><br>
            The expression is executed and the result is returned.
            <br><br>
            Lambda functions can take any number of arguments.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = lambda a : a + 10
print(x(5))

x = lambda a, b : a * b
print(x(5, 6))

x = lambda a, b, c : a + b + c
print(x(5, 6, 2))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The power of lambda is better shown when you use them as an anonymous function inside another function.
            <br><br>
            Say you have a function definition that takes one argument, and that argument will be multiplied with an
            unknown number.
            <br><br>
            Use that function definition to make a function that always doubles or triples the number you send in.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
print(mydoubler(11))

mytripler = myfunc(3)
print(mytripler(11))</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Object-Oriented Programming</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Classes/Objects</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Python is an object oriented programming language.
            <br><br>
            Almost everything in Python is an object, with its properties and methods.
            <br><br>
            A Class is like an object constructor, or a "blueprint" for creating objects.
            <br><br>
            To create a class, use the keyword <code>class</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyClass:
  x = 5</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Now we can use the class named MyClass to create objects.
        </div>
        <div class="right-column">
            <pre><code class="language-python">p1 = MyClass()
print(p1.x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The examples above are classes and objects in their simplest form, and are not really useful in real life
            applications.
            <br><br>
            To understand the meaning of classes we have to understand the built-in <code>__init__()</code> method.
            <br><br>
            All classes have a method called <code>__init__()</code>, which is always executed when the class is being
            initiated.
            <br><br>
            Use the <code>__init__()</code> method to assign values to object properties, or other operations that are
            necessary to
            do when the object is being created.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

p1 = Person("John", 36)

print(p1.name)
print(p1.age)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>__str__()</code> method controls what should be returned when the class object is represented as a
            string.
            <br><br>
            If the <code>__str__()</code> method is not set, the string representation of the object is returned.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

# Remove this method to see what happens
  def __str__(self):
    return f"{self.name}({self.age})"

p1 = Person("John", 36)

print(p1)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can create your own methods inside objects. Methods in objects are functions that belong to the object.
            <br><br>
            Let us create a method in the Person class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
p1.myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>self</code> parameter is a reference to the current instance of the class, and is used to access
            variables that
            belong to the class.
            <br><br>
            It does not have to be named <code>self</code>, you can call it whatever you like, but it has to be the
            first parameter
            of any function in the class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  def __init__(mysillyobject, name, age):
    mysillyobject.name = name
    mysillyobject.age = age

  def myfunc(abc):
    print("Hello my name is " + abc.name)

p1 = Person("John", 36)
p1.myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can modify properties on objects like this.
        </div>
        <div class="right-column">
            <pre><code class="language-python">p1.age = 40</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can delete properties on objects by using the <code>del</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">del p1.age</code></pre>
        </div>
    </div>

    <hr>


    <div class="container-row scrollable">
        <div>
            You can delete objects by using the <code>del</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">del p1</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <code>class</code> definitions cannot be empty, but if you for some reason have a <code>class</code>
            definition with no content, put in the <code>pass</code> statement to avoid getting an error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Person:
  pass
</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Inheritance</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Inheritance allows us to define a class that inherits all the methods and properties from another class.
            <br><br>
            <b>Parent class</b> is the class being inherited from, also called base class.
            <br><br>
            <b>Child class</b> is the class that inherits from another class, also called derived class.
            <br><br>
            To create a class that inherits the functionality from another class, send the parent class as a parameter
            when creating the child class.
            <br><br>
            Now the Student class has the same properties and methods as the Person class.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Parent class
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

# Child class
class Student(Person):
  pass

x = Student("Mike", "Olsen")
x.printname()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            So far we have created a child class that inherits the properties and methods from its parent.
            <br><br>
            We want to add the <code>__init__()</code> function to the child class.
            <br><br>
            The child's <code>__init__()</code> function overrides the inheritance of the parent's
            <code>__init__()</code> function.
            <br><br>
            To keep the inheritance of the parent's <code>__init__()</code> function, add a call to the parent's
            <code>__init__()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    Person.__init__(self, fname, lname)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            By using the <code>super()</code> function, you do not have to use the name of the parent element, it will
            automatically inherit the methods and properties from its parent.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Add a property called <code>graduationyear</code> to the <code>Student</code> class.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)
    self.graduationyear = 2019</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            In the example on the right, the year <code>2019</code> should be a variable, and passed into the
            <code>Student</code> class when creating student objects.
            To do so, add another parameter in the <code>__init__()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

x = Student("Mike", "Olsen", 2019)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Add a method called <code>welcome</code> to the <code>Student</code> class.
            <br><br>
            If you add a method in the child class with the same name as a function in the parent class, the inheritance
            of the parent method will be overridden.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

  def welcome(self):
    print("Welcome", self.firstname, self.lastname, "to the class of", self.graduationyear)</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Iterators</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <div class="container-row scrollable">
        <div>
            An iterator is an object that contains a countable number of values.
            <br><br>
            An iterator is an object that can be iterated upon, meaning that you can traverse through all the values.
            <br><br>
            Technically, in Python, an iterator is an object which implements the iterator protocol, which consist of
            the methods <code>__iter__()</code> and <code>__next__()</code>.
            <br><br>
            Lists, tuples, dictionaries, strings and sets are all iterable objects. They are iterable containers which
            you can get an iterator from.
            <br><br>
            All these objects have a <code>iter()</code> method which is used to get an iterator:
        </div>
        <div class="right-column">
            <pre><code class="language-python">mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))

mystr = "banana"
myit = iter(mystr)

print(next(myit))
print(next(myit))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>for</code> loop actually creates an iterator object and executes the <code>next()</code> method
            for each loop.
        </div>
        <div class="right-column">
            <pre><code class="language-python">mystr = "banana"

for x in mystr:
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            To create an object/class as an iterator you have to implement the methods <code>__iter__()</code> and
            <code>__next__()</code> to your
            object.
            <br><br>
            As you have already learned, all classes have a function called <code>__init__()</code>, which allows you to
            do some
            initializing when the object is being created.
            <br><br>
            The <code>__iter__()</code> method acts similar, you can do operations (initializing etc.), but must always
            return the
            iterator object itself.
            <br><br>
            The <code>__next__()</code> method also allows you to do operations, and must return the next item in the
            sequence.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))</code></pre>
        </div>
    </div>

    <hr>


    <div class="container-row scrollable">
        <div>
            The example above would continue forever if you had enough <code>next()</code> statements, or if it was used
            in a <code>for</code> loop.
            <br><br>
            To prevent the iteration from going on forever, we can use the <code>StopIteration</code> statement.
            <br><br>
            In the <code>__next__()</code> method, we can add a terminating condition to raise an error if the iteration
            is done a specified number of times:
        </div>
        <div class="right-column">
            <pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Polymorphism</span>
    <div style="height: 0.4em;"></div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The word "polymorphism" means "many forms", and in programming it refers to methods/functions/operators with
            the same name that can be executed on many objects or classes.
            <br><br>
            An example of a Python function that can be used on different objects is the <code>len()</code> function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = "Hello World!"
print(len(x))

mytuple = ("apple", "banana", "cherry")
print(len(mytuple))</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Polymorphism is often used in Class methods, where we can have multiple classes with the same method name.
            <br><br>
            For example, say we have three classes: <code>Car</code>, <code>Boat</code>, and <code>Plane</code>, and
            they all have a method called <code>move()</code>.
            <br><br>
            Look at the for loop at the end. Because of polymorphism we can execute the same method for all three
            classes.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Car:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Drive!")

class Boat:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Sail!")

class Plane:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang")       #Create a Car object
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747")     #Create a Plane object

for x in (car1, boat1, plane1):
  x.move()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            What about classes with child classes with the same name? Can we use polymorphism there?
            <br><br>
            Yes. If we use the example above and make a parent class called <code>Vehicle</code>, and make
            <code>Car</code>, <code>Boat</code>, <code>Plane</code> child
            classes of <code>Vehicle</code>, the child classes inherits the <code>Vehicle</code> methods, but can
            override them.
            <br><br>
            In the example you can see that the <code>Car</code> class is empty, but it inherits <code>brand</code>,
            <code>model</code>, and <code>move()</code> from Vehicle.
            <br><br>
            The <code>Boat</code> and <code>Plane</code> classes also inherit <code>brand</code>, <code>model</code>,
            and <code>move()</code> from <code>Vehicle</code>, but they both override the <code>move()</code> method.
            <br><br>
            Because of polymorphism we can execute the same method for all classes.
        </div>
        <div class="right-column">
            <pre><code class="language-python">class Vehicle:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Move!")

class Car(Vehicle):
  pass

class Boat(Vehicle):
  def move(self):
    print("Sail!")

class Plane(Vehicle):
  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang")       #Create a Car object
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747")     #Create a Plane object

for x in (car1, boat1, plane1):
  print(x.brand)
  print(x.model)
  x.move()</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Scope</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            A variable is only available from inside the region it is created.
            This is called <b>scope</b>.
            <br><br>
            A variable created inside a function belongs to the local scope of that function, and can only be used
            inside that function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunc():
  x = 300
  print(x)

myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            As explained in the example above, the variable <code>x</code> is not available outside the function,
            but it is available for any function inside the function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunc():
  x = 300
  def myinnerfunc():
    print(x)
  myinnerfunc()

myfunc()</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            A variable created in the main body of the Python code is a global variable and belongs to the global scope.
            <br><br>
            Global variables are available from within any scope, global and local.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = 300

def myfunc():
  print(x)

myfunc()

print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you operate with the same variable name inside and outside of a function, Python will treat them as two
            separate variables, one available in the global scope (outside the function) and one available in the local
            scope (inside the function).
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = 300

def myfunc():
  x = 200
  print(x)

myfunc()

print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            If you need to create a global variable, but are stuck in the local scope, you can use the
            <code>global</code> keyword.
            <br><br>
            The <code>global</code> keyword makes the variable global.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunc():
  global x
  x = 300

myfunc()

print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Also, use the <code>global</code> keyword if you want to make a change to a global variable inside a
            function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = 300

def myfunc():
  global x
  x = 200

myfunc()

print(x)</code></pre>
        </div>
    </div>

    <hr>
    <div class="container-row scrollable">
        <div>
            The <code>nonlocal</code> keyword is used to work with variables inside nested functions.
            <br><br>
            The <code>nonlocal</code> keyword makes the variable belong to the outer function.
        </div>
        <div class="right-column">
            <pre><code class="language-python">def myfunc1():
  x = "Jane"
  def myfunc2():
    nonlocal x
    x = "hello"
  myfunc2()
  return x

print(myfunc1())</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Modules</span>
    <div style="height: 0.4em;"></div>

    <div class="container-row scrollable">
        <div>
            Consider a module to be the same as a code library.
            <br><br>
            A file containing a set of functions you want to include in your application.
            <br><br>
            To create a module just save the code you want in a file with the file extension <code>.py</code>.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Save this code in a file named mymodule.py
def greeting(name):
  print("Hello, " + name)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Now we can use the module we just created, by using the <code>import</code> statement.
            <br><br>
            Note: When using a function from a module, use the syntax: module_name.function_name.
            <br><br>
            There are several built-in modules in Python, which you can import whenever you like.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule

mymodule.greeting("Jonathan")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The module can contain functions, as already described, but also variables of all types.
        </div>
        <div class="right-column">
            <pre><code class="language-python"># Add this code to the file mymodule.py
person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            Import the module named mymodule, and access the person1 dictionary.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule

a = mymodule.person1["age"]
print(a)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can create an alias when you import a module, by using the <code>as</code> keyword.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import mymodule as mx

a = mx.person1["age"]
print(a)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            There is a built-in <code>dir()</code> function to list all the function names (or variable names) in a
            module.
            <br><br>
            The <code>dir()</code> function can be used on all modules, also the ones you create yourself.
        </div>
        <div class="right-column">
            <pre><code class="language-python">import platform

x = dir(platform)
print(x)</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can choose to import only parts from a module, by using the <code>from</code> keyword.
            <br><br>
            When importing using the <code>from</code> keyword, do not use the module name when referring to elements in
            the module.
        </div>
        <div class="right-column">
            <pre><code class="language-python">from mymodule import person1

print(person1["age"])</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Dates</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Math</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">JSON</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Regular Expression</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">PIP</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Errors and Exceptions</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            When an error occurs, or exception as we call it, Python will normally stop and generate an error message.
            <br><br>
            These exceptions can be handled using the <code>try</code> statement.
            <br><br>
            Since the try block raises an error, the except block will be executed.
            <br><br>
            Without the try block, the program will crash and raise an error:
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except:
  print("An exception occurred")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can define as many exception blocks as you want, e.g. if you want to execute a special block of code for
            a special kind of error.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            You can use the <code>else</code> keyword to define a block of code to be executed if no errors were raised.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print("Hello")
except:
  print("Something went wrong")
else:
  print("Nothing went wrong")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            The <code>finally</code> block, if specified, will be executed regardless if the try block raises an error
            or not.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            This can be useful to close objects and clean up resources.
            <br><br>
            The program can continue, without leaving the file object open.
        </div>
        <div class="right-column">
            <pre><code class="language-python">try:
  f = open("demofile.txt")
  try:
    f.write("Lorum Ipsum")
  except:
    print("Something went wrong when writing to the file")
  finally:
    f.close()
except:
  print("Something went wrong when opening the file")</code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            As a Python developer you can choose to throw an exception if a condition occurs.
            <br><br>
            To throw (or raise) an exception, use the <code>raise</code> keyword.
            <br><br>
            You can define what kind of error to raise, and the text to print to the user.
        </div>
        <div class="right-column">
            <pre><code class="language-python">x = -1

if x < 0:
  raise Exception("Sorry, no numbers below zero")

x = "hello"

if not type(x) is int:
  raise TypeError("Only integers are allowed")</code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">User Input</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <span style="font-weight: bold;">Virtual Environment</span>
    <div style="height: 0.4em;"></div>


    <div class="container-row scrollable">
        <div>
            <i>Details later!</i>
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <div class="container-row scrollable">
        <div>
            <!---->
        </div>
        <div class="right-column">
            <pre><code class="language-python"></code></pre>
        </div>
    </div>

    <hr>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>

</html>